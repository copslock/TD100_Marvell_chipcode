/*
 * A V4L2 driver for OmniVision OV5642 cameras.
 *
 * Copyright 2006 One Laptop Per Child Association, Inc.  Written
 * by Jonathan Corbet with substantial inspiration from Mark
 * McClelland's ovcamchip code.
 *
 * Copyright 2006-7 Jonathan Corbet <corbet@lwn.net>
 *
 * This file may be distributed under the terms of the GNU General
 * Public License, version 2.
 */
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/delay.h>
#include <linux/videodev.h>
#include <media/v4l2-common.h>
#include <media/v4l2-chip-ident.h>
#include <linux/i2c.h>
#include <mach/hardware.h>
#include <mach/camera.h>
#include <mach/mfp.h>

#include <linux/clk.h>

MODULE_DESCRIPTION("A low-level driver for OmniVision ov5642 sensors");
MODULE_LICENSE("GPL");

/*
 * Basic window sizes.  These probably belong somewhere more globally
 * useful.
 */

/*for OV5642 porting*/
#define REG_PIDH	0x300a
#define REG_PIDL	0x300b
#define REG_SYSCTRL	0x3008
#define SW_RESET	0x80

#define REG_AWB_EN	0x3406
#define REG_AE_EN	0x3503
#define REG_AF_EN	0x3024

#define REG_RESERVED	0xffff
#define END_VALUE	0xff
#define END_SIGN	{REG_RESERVED, END_VALUE}

#define AWB_DIS	0x01
#define AE_EN	0x05
#define AF_EN	0x03
/* The maximum allowed times for repeating OV5642 detection */
#define MAX_DETECT_NUM	5

/* Flash related constants */
enum OV5642_STROBE {
	/* Strobe control registers */
	REG_SYS_RESET	= 0x3000,
	REG_CLK_ENABLE	= 0x3004,
	REG_PAD_OUTPUT	= 0x3016,
	REG_STRB_CTRL	= 0x3B00,
	REG_FREX_MODE	= 0x3B07,

	// Strobe modes
	STRB_MODE_XENON	= 0x00,
	STRB_MODE_LED1,
	STRB_MODE_LED2,
	STRB_MODE_LED3,
	STRB_MODE_MASK	= 0x03,

	STRB_WIDTH_MASK	= 0x0C,
	STRB_RQST	= 0x80,
};

enum flash_arg_format {
	FLASH_ARG_TIME_OFF	= 0,
	FLASH_ARG_MODE_0	= 0,
	FLASH_ARG_MODE_1,
	FLASH_ARG_MODE_2,
	FLASH_ARG_MODE_3,
	FLASH_ARG_MODE_EVER	= FLASH_ARG_MODE_0, /* Always on till send off  */
	FLASH_ARG_MODE_TIMED	= FLASH_ARG_MODE_1, /* On for some time */
	FLASH_ARG_MODE_REPEAT	= FLASH_ARG_MODE_2, /* Repeatedlly on */
	FLASH_ARG_MODE_BLINK	= FLASH_ARG_MODE_3, /* On for some jeffies defined by H/W */
	FLASH_ARG_MODE_MAX,	/* Equal or greater mode considered invalid */
	FLASH_ARG_LUMI_OFF	= 0, /* Flash off */
	FLASH_ARG_LUMI_FULL,
	FLASH_ARG_LUMI_DIM1,	/* One fifth luminance*/
	FLASH_ARG_LUMI_DIM2,	/* One third luminance, not supported in H/W configuration */
	FLASH_ARG_LUMI_MAX,	/* Equal or greater luminance considered invalid */
};

#define setbit(reg, mask) \
do{ \
	unsigned char val; \
	ov5642_read(client, reg, &val); \
	/*printk(KERN_NOTICE"Reg0x%4X: 0x%2X -> 0x%2X\n", reg, val, (val)|(mask));*/ \
	val |= (mask); \
	ov5642_write(client, reg, val); \
}while (0)

#define clrbit(reg, mask) \
do{ \
	unsigned char val; \
	ov5642_read(client, reg, &val);	\
	/*printk(KERN_NOTICE"Reg0x%4X: 0x%2X -> 0x%2X\n", reg, val, (val)&(~(mask)));*/ \
	val &= (~(mask));	\
	ov5642_write(client, reg, val);	\
}while (0)

/*
 * Information we maintain about a known sensor.
 */
struct cam_flash_struct {
	unsigned char	mode;
/*	flash mode
 *	00 Continous flash, flash on when on req flash off when off req.
 *	01 One flash, the flash strobe is opened for a period of time specified
 *	   by high 3 bytes.
 *	10 periodic flash, the flash is on periodiclly the period is specified
 *	   by high 3 bytes.
 *	11 pulse flash, flash one time for a very short pulse, width of the
 *	   pulse is specified by bit
 */
	unsigned char	brightness;
	unsigned int 	duration;
};
struct ov5642_format_struct;  /* coming later */
struct ov5642_info {
	struct ov5642_format_struct *fmt;  /* Current format */
	unsigned char sat;		/* Saturation value */
	int hue;			/* Hue value */
	struct cam_flash_struct flash;	/* Flash strobe related info */
};

/*
 * The default register settings, as obtained from OmniVision.  There
 * is really no making sense of most of these - lots of "reserved" values
 * and such.
 *
 * These settings give VGA YUYV.
 */

struct regval_list {
	u16 reg_num;
	unsigned char value;
};
static struct regval_list ov5642_bridge_res_qcif[] = {
	/* 176 x 144 */
	{0x3804, 0x02},
	{0x3805, 0x80},
	{0x3806, 0x01},
	{0x3807, 0xe0},
	{0x3808, 0x00},
	{0x3809, 0xB0},
	{0x380a, 0x00},
	{0x380b, 0x90},
	END_SIGN
};
static struct regval_list ov5642_bridge_res_cif[] = {
        /* 176 x 144 */
        {0x3804, 0x02},
        {0x3805, 0x80},
        {0x3806, 0x01},
        {0x3807, 0xe0},
        {0x3808, 0x01},
        {0x3809, 0x60},
        {0x380a, 0x01},
        {0x380b, 0x20},
	END_SIGN
};
static struct regval_list ov5642_bridge_res_qvga[] = {
	/* 320 x 240 */
	{0x3804, 0x02},
	{0x3805, 0x80},
	{0x3806, 0x01},
	{0x3807, 0xe0},
	{0x3808, 0x01},
	{0x3809, 0x40},
	{0x380a, 0x00},
	{0x380b, 0xf0},
	END_SIGN
};
static struct regval_list ov5642_bridge_res_vga[] = {
	/* 640 x 480 */
	{0x3804, 0x02},
	{0x3805, 0x80},
	{0x3806, 0x01},
	{0x3807, 0xe0},
	{0x3808, 0x02},
	{0x3809, 0x80},
	{0x380a, 0x01},
	{0x380b, 0xe0},
	END_SIGN
};
static struct regval_list ov5642_bridge_mode_start[] = {
	{0x3103, 0x93},
	{0x3008, 0x82},
	{0x3008, 0x42},
	{0x3503, 0x07},
	{0x3509, 0x1f},
	{0x3012, 0x00},
	{0x3011, 0x09},
	{0x3010, 0x11},
	{0x5000, 0x00},
	{0x5001, 0x00},
	{0x5580, 0x02},
	{0x5583, 0x50},
	{0x5584, 0x50},
	{0x300f, 0x0a},/*;0e*/
	{0x3029, 0x01},/*;01*/
	{0x3001, 0x40},
	{0x3002, 0x00},
	{0x3005, 0xbf},
	{0x3814, 0x62},
	{0x3815, 0x21},
	{0x3017, 0x00},
	{0x3018, 0x02},
	{0x3000, 0xf9},
	{0x4801, 0x0f},
	{0x4842, 0x01},
	{0x3003, 0x03},
	{0x3003, 0x01},
	{0x3007, 0x3b},
	{0x300e, 0x04},
	{0x4803, 0x50},
	END_SIGN
};
static struct regval_list ov5642_bridge_mode_end[] = {
	{0x3810, 0x00},
	{0x501f, 0x00},
	{0x3818, 0x81},
	{0x4300, 0x32},/*try 0x32. {0x4300, 0x30},*/
	{0x3008, 0x02},
	END_SIGN
};


static struct regval_list __attribute((unused)) ov5642_fmt_rgb565[] = {
	/* RGB OUTPUT */
	{0x460c ,0x20},
	{0x460b ,0x37},
	{0x471c ,0xd0},
	{0x3815 ,0x01},
	{0x3818 ,0xc1},
	{0x501f ,0x01},
	{0x4300 ,0x61},
	{0x3002 ,0x1c},
	{0x3819 ,0x80},
	{0x5002 ,0xf8},

	{0xFFFF, 0xFF}
};

static struct regval_list ov5642_fmt_yuv422[] = {
	/* YUV OUTPUT */
	{0x501f, 0x00},
	{0x4300, 0x32},
	END_SIGN
};

static struct regval_list ov5642_yuv_1080p[] = {
	/* MIPI_2lane_1080P_YUV 7.5fps */
	{0x3103 ,0x93},
	{0x3008 ,0x82},
	{0x3017 ,0x7f},
	{0x3018 ,0xfc},
	{0x3810 ,0xc2},
	{0x3615 ,0xf0},
	{0x3000 ,0x00},
	{0x3001 ,0x00},
	{0x3002 ,0x00},
	{0x3003 ,0x00},
	{0x3004 ,0xff},
	/* 0x3030, enable DVP*/
	{0x3030 ,0x0b},
	{0x3011 ,0x08},
	{0x3010 ,0x10},
	{0x3604 ,0x60},
	{0x3622 ,0x60},
	{0x3621 ,0x09},
	{0x3709 ,0x00},
	{0x4000 ,0x21},
	{0x401d ,0x22},
	{0x3600 ,0x54},
	{0x3605 ,0x04},
	{0x3606 ,0x3f},
	{0x3c01 ,0x80},
	{0x300d ,0x22},
	{0x3623 ,0x22},
	{0x5000 ,0x4f},
	{0x5020 ,0x04},
	{0x5181 ,0x79},
	{0x5182 ,0x00},
	{0x5185 ,0x22},
	{0x5197 ,0x01},
	{0x5500 ,0x0a},
	{0x5504 ,0x00},
	{0x5505 ,0x7f},
	{0x5080 ,0x08},
	{0x300e ,0x18},
	{0x4610 ,0x00},
	{0x471d ,0x05},
	{0x4708 ,0x06},
	{0x370c ,0xa0},
	{0x3808 ,0x0a},
	{0x3809 ,0x20},
	{0x380a ,0x07},
	{0x380b ,0x98},
	{0x380c ,0x0c},
	{0x380d ,0x80},
	{0x380e ,0x07},
	{0x380f ,0xd0},
	{0x5687 ,0x94},
	{0x501f ,0x00},
	{0x5000 ,0x4f},
	{0x5001 ,0xcf},
	/* yuv420, uyvy sequence*/
	{0x4300 ,0x32},
	{0x4300 ,0x32},
	{0x460b ,0x35},
	{0x471d ,0x00},
	{0x3002 ,0x0c},
	{0x3002 ,0x00},
	{0x4713 ,0x03},
	{0x471c ,0x50},
	{0x4721 ,0x02},
	{0x4402 ,0x90},
	{0x460c ,0x22},
	{0x3815 ,0x44},
	{0x3503 ,0x07},
	{0x3501 ,0x73},
	{0x3502 ,0x80},
	{0x350b ,0x00},
	{0x3818 ,0xc8},
	{0x3801 ,0x88},
	{0x3824 ,0x11},
	{0x3a00 ,0x78},
	{0x3a1a ,0x04},
	{0x3a13 ,0x30},
	{0x3a18 ,0x00},
	{0x3a19 ,0x7c},
	{0x3a08 ,0x12},
	{0x3a09 ,0xc0},
	{0x3a0a ,0x0f},
	{0x3a0b ,0xa0},
	{0x350c ,0x07},
	{0x350d ,0xd0},
	{0x3a0d ,0x08},
	{0x3a0e ,0x06},
	{0x3500 ,0x00},
	{0x3501 ,0x00},
	{0x3502 ,0x00},
	{0x350a ,0x00},
	{0x350b ,0x00},
	{0x3503 ,0x00},
	{0x3a0f ,0x3c},
	{0x3a10 ,0x32},
	{0x3a1b ,0x3c},
	{0x3a1e ,0x32},
	{0x3a11 ,0x80},
	{0x3a1f ,0x20},
	{0x3030 ,0x0b},
	{0x3a02 ,0x00},
	{0x3a03 ,0x7d},
	{0x3a04 ,0x00},
	{0x3a14 ,0x00},
	{0x3a15 ,0x7d},
	{0x3a16 ,0x00},
	{0x3a00 ,0x78},
	{0x3a08 ,0x09},
	{0x3a09 ,0x60},
	{0x3a0a ,0x07},
	{0x3a0b ,0xd0},
	{0x3a0d ,0x10},
	{0x3a0e ,0x0d},
	{0x4407 ,0x04},
	{0x5193 ,0x70},
	{0x589b ,0x00},
	{0x589a ,0xc0},
	{0x401e ,0x20},
	{0x4001 ,0x42},
	{0x401c ,0x06},
	{0x3825 ,0xac},
	{0x3827 ,0x0c},
	{0x528a ,0x01},
	{0x528b ,0x04},
	{0x528c ,0x08},
	{0x528d ,0x10},
	{0x528e ,0x20},
	{0x528f ,0x28},
	{0x5290 ,0x30},
	{0x5292 ,0x00},
	{0x5293 ,0x01},
	{0x5294 ,0x00},
	{0x5295 ,0x04},
	{0x5296 ,0x00},
	{0x5297 ,0x08},
	{0x5298 ,0x00},
	{0x5299 ,0x10},
	{0x529a ,0x00},
	{0x529b ,0x20},
	{0x529c ,0x00},
	{0x529d ,0x28},
	{0x529e ,0x00},
	{0x529f ,0x30},
	{0x5282 ,0x00},
	{0x5300 ,0x00},
	{0x5301 ,0x20},
	{0x5302 ,0x00},
	{0x5303 ,0x7c},
	{0x530c ,0x00},
	{0x530d ,0x0c},
	{0x530e ,0x20},
	{0x530f ,0x80},
	{0x5310 ,0x20},
	{0x5311 ,0x80},
	{0x5308 ,0x20},
	{0x5309 ,0x40},
	{0x5304 ,0x00},
	{0x5305 ,0x30},
	{0x5306 ,0x00},
	{0x5307 ,0x80},
	{0x5314 ,0x08},
	{0x5315 ,0x20},
	{0x5319 ,0x30},
	{0x5316 ,0x10},
	{0x5317 ,0x00},
	{0x5318 ,0x02},
	{0x5380 ,0x01},
	{0x5381 ,0x00},
	{0x5382 ,0x00},
	{0x5383 ,0x4e},
	{0x5384 ,0x00},
	{0x5385 ,0x0f},
	{0x5386 ,0x00},
	{0x5387 ,0x00},
	{0x5388 ,0x01},
	{0x5389 ,0x15},
	{0x538a ,0x00},
	{0x538b ,0x31},
	{0x538c ,0x00},
	{0x538d ,0x00},
	{0x538e ,0x00},
	{0x538f ,0x0f},
	{0x5390 ,0x00},
	{0x5391 ,0xab},
	{0x5392 ,0x00},
	{0x5393 ,0xa2},
	{0x5394 ,0x08},
	{0x5480 ,0x14},
	{0x5481 ,0x21},
	{0x5482 ,0x36},
	{0x5483 ,0x57},
	{0x5484 ,0x65},
	{0x5485 ,0x71},
	{0x5486 ,0x7d},
	{0x5487 ,0x87},
	{0x5488 ,0x91},
	{0x5489 ,0x9a},
	{0x548a ,0xaa},
	{0x548b ,0xb8},
	{0x548c ,0xcd},
	{0x548d ,0xdd},
	{0x548e ,0xea},
	{0x548f ,0x1d},
	{0x5490 ,0x05},
	{0x5491 ,0x00},
	{0x5492 ,0x04},
	{0x5493 ,0x20},
	{0x5494 ,0x03},
	{0x5495 ,0x60},
	{0x5496 ,0x02},
	{0x5497 ,0xb8},
	{0x5498 ,0x02},
	{0x5499 ,0x86},
	{0x549a ,0x02},
	{0x549b ,0x5b},
	{0x549c ,0x02},
	{0x549d ,0x3b},
	{0x549e ,0x02},
	{0x549f ,0x1c},
	{0x54a0 ,0x02},
	{0x54a1 ,0x04},
	{0x54a2 ,0x01},
	{0x54a3 ,0xed},
	{0x54a4 ,0x01},
	{0x54a5 ,0xc5},
	{0x54a6 ,0x01},
	{0x54a7 ,0xa5},
	{0x54a8 ,0x01},
	{0x54a9 ,0x6c},
	{0x54aa ,0x01},
	{0x54ab ,0x41},
	{0x54ac ,0x01},
	{0x54ad ,0x20},
	{0x54ae ,0x00},
	{0x54af ,0x16},
	{0x54b0 ,0x01},
	{0x54b1 ,0x20},
	{0x54b2 ,0x00},
	{0x54b3 ,0x10},
	{0x54b4 ,0x00},
	{0x54b5 ,0xf0},
	{0x54b6 ,0x00},
	{0x54b7 ,0xdf},
	{0x5402 ,0x3f},
	{0x5403 ,0x00},
	{0x3406 ,0x00},
	{0x5180 ,0xff},
	{0x5181 ,0x52},
	{0x5182 ,0x11},
	{0x5183 ,0x14},
	{0x5184 ,0x25},
	{0x5185 ,0x24},
	{0x5186 ,0x06},
	{0x5187 ,0x08},
	{0x5188 ,0x08},
	{0x5189 ,0x7c},
	{0x518a ,0x60},
	{0x518b ,0xb2},
	{0x518c ,0xb2},
	{0x518d ,0x44},
	{0x518e ,0x3d},
	{0x518f ,0x58},
	{0x5190 ,0x46},
	{0x5191 ,0xf8},
	{0x5192 ,0x04},
	{0x5193 ,0x70},
	{0x5194 ,0xf0},
	{0x5195 ,0xf0},
	{0x5196 ,0x03},
	{0x5197 ,0x01},
	{0x5198 ,0x04},
	{0x5199 ,0x12},
	{0x519a ,0x04},
	{0x519b ,0x00},
	{0x519c ,0x06},
	{0x519d ,0x82},
	{0x519e ,0x00},
	{0x5025 ,0x80},
	{0x3a0f ,0x38},
	{0x3a10 ,0x30},
	{0x3a1b ,0x3a},
	{0x3a1e ,0x2e},
	{0x3a11 ,0x60},
	{0x3a1f ,0x10},
	{0x5688 ,0xa6},
	{0x5689 ,0x6a},
	{0x568a ,0xea},
	{0x568b ,0xae},
	{0x568c ,0xa6},
	{0x568d ,0x6a},
	{0x568e ,0x62},
	{0x568f ,0x26},
	{0x5583 ,0x40},
	{0x5584 ,0x40},
	{0x5580 ,0x02},
	{0x5000 ,0xcf},
	{0x5800 ,0x27},
	{0x5801 ,0x19},
	{0x5802 ,0x12},
	{0x5803 ,0x0f},
	{0x5804 ,0x10},
	{0x5805 ,0x15},
	{0x5806 ,0x1e},
	{0x5807 ,0x2f},
	{0x5808 ,0x15},
	{0x5809 ,0x0d},
	{0x580a ,0x0a},
	{0x580b ,0x09},
	{0x580c ,0x0a},
	{0x580d ,0x0c},
	{0x580e ,0x12},
	{0x580f ,0x19},
	{0x5810 ,0x0b},
	{0x5811 ,0x07},
	{0x5812 ,0x04},
	{0x5813 ,0x03},
	{0x5814 ,0x03},
	{0x5815 ,0x06},
	{0x5816 ,0x0a},
	{0x5817 ,0x0f},
	{0x5818 ,0x0a},
	{0x5819 ,0x05},
	{0x581a ,0x01},
	{0x581b ,0x00},
	{0x581c ,0x00},
	{0x581d ,0x03},
	{0x581e ,0x08},
	{0x581f ,0x0c},
	{0x5820 ,0x0a},
	{0x5821 ,0x05},
	{0x5822 ,0x01},
	{0x5823 ,0x00},
	{0x5824 ,0x00},
	{0x5825 ,0x03},
	{0x5826 ,0x08},
	{0x5827 ,0x0c},
	{0x5828 ,0x0e},
	{0x5829 ,0x08},
	{0x582a ,0x06},
	{0x582b ,0x04},
	{0x582c ,0x05},
	{0x582d ,0x07},
	{0x582e ,0x0b},
	{0x582f ,0x12},
	{0x5830 ,0x18},
	{0x5831 ,0x10},
	{0x5832 ,0x0c},
	{0x5833 ,0x0a},
	{0x5834 ,0x0b},
	{0x5835 ,0x0e},
	{0x5836 ,0x15},
	{0x5837 ,0x19},
	{0x5838 ,0x32},
	{0x5839 ,0x1f},
	{0x583a ,0x18},
	{0x583b ,0x16},
	{0x583c ,0x17},
	{0x583d ,0x1e},
	{0x583e ,0x26},
	{0x583f ,0x53},
	{0x5840 ,0x10},
	{0x5841 ,0x0f},
	{0x5842 ,0x0d},
	{0x5843 ,0x0c},
	{0x5844 ,0x0e},
	{0x5845 ,0x09},
	{0x5846 ,0x11},
	{0x5847 ,0x10},
	{0x5848 ,0x10},
	{0x5849 ,0x10},
	{0x584a ,0x10},
	{0x584b ,0x0e},
	{0x584c ,0x10},
	{0x584d ,0x10},
	{0x584e ,0x11},
	{0x584f ,0x10},
	{0x5850 ,0x0f},
	{0x5851 ,0x0c},
	{0x5852 ,0x0f},
	{0x5853 ,0x10},
	{0x5854 ,0x10},
	{0x5855 ,0x0f},
	{0x5856 ,0x0e},
	{0x5857 ,0x0b},
	{0x5858 ,0x10},
	{0x5859 ,0x0d},
	{0x585a ,0x0d},
	{0x585b ,0x0c},
	{0x585c ,0x0c},
	{0x585d ,0x0c},
	{0x585e ,0x0b},
	{0x585f ,0x0c},
	{0x5860 ,0x0c},
	{0x5861 ,0x0c},
	{0x5862 ,0x0d},
	{0x5863 ,0x08},
	{0x5864 ,0x11},
	{0x5865 ,0x18},
	{0x5866 ,0x18},
	{0x5867 ,0x19},
	{0x5868 ,0x17},
	{0x5869 ,0x19},
	{0x586a ,0x16},
	{0x586b ,0x13},
	{0x586c ,0x13},
	{0x586d ,0x12},
	{0x586e ,0x13},
	{0x586f ,0x16},
	{0x5870 ,0x14},
	{0x5871 ,0x12},
	{0x5872 ,0x10},
	{0x5873 ,0x11},
	{0x5874 ,0x11},
	{0x5875 ,0x16},
	{0x5876 ,0x14},
	{0x5877 ,0x11},
	{0x5878 ,0x10},
	{0x5879 ,0x0f},
	{0x587a ,0x10},
	{0x587b ,0x14},
	{0x587c ,0x13},
	{0x587d ,0x12},
	{0x587e ,0x11},
	{0x587f ,0x11},
	{0x5880 ,0x12},
	{0x5881 ,0x15},
	{0x5882 ,0x14},
	{0x5883 ,0x15},
	{0x5884 ,0x15},
	{0x5885 ,0x15},
	{0x5886 ,0x13},
	{0x5887 ,0x17},
	{0x3710 ,0x10},
	{0x3632 ,0x51},
	{0x3702 ,0x10},
	{0x3703 ,0xb2},
	{0x3704 ,0x18},
	{0x370b ,0x40},
	{0x370d ,0x03},
	{0x3631 ,0x01},
	{0x3632 ,0x52},
	{0x3606 ,0x24},
	{0x3620 ,0x96},
	{0x5785 ,0x07},
	{0x3a13 ,0x30},
	{0x3600 ,0x52},
	{0x3604 ,0x48},
	{0x3606 ,0x1b},
	{0x370d ,0x0b},
	{0x370f ,0xc0},
	{0x3709 ,0x01},
	{0x3823 ,0x00},
	{0x5007 ,0x00},
	{0x5009 ,0x00},
	{0x5011 ,0x00},
	{0x5013 ,0x00},
	{0x519e ,0x00},
	{0x5086 ,0x00},
	{0x5087 ,0x00},
	{0x5088 ,0x00},
	{0x5089 ,0x00},
	{0x302b ,0x00},
	{0x3503 ,0x07},
	{0x3011 ,0x07},
	{0x350c ,0x04},
	{0x350d ,0x58},
	{0x3801 ,0x8a},
	{0x3803 ,0x0a},
	{0x3804 ,0x07},
	{0x3805 ,0x80},
	{0x3806 ,0x04},
	{0x3807 ,0x38},
	{0x3808 ,0x07},
	{0x3809 ,0x80},
	{0x380a ,0x04},
	{0x380b ,0x38},
	{0x380c ,0x09},
	{0x380d ,0xd6},
	{0x380e ,0x04},
	{0x380f ,0x58},
	{0x381c ,0x11},
	{0x381d ,0xba},
	{0x381e ,0x04},
	{0x381f ,0x48},
	{0x3820 ,0x04},
	{0x3821 ,0x18},
	{0x3a08 ,0x14},
	{0x3a09 ,0xe0},
	{0x3a0a ,0x11},
	{0x3a0b ,0x60},
	{0x3a0d ,0x04},
	{0x3a0e ,0x03},
	{0x5682 ,0x07},
	{0x5683 ,0x60},
	{0x5686 ,0x04},
	{0x5687 ,0x1c},
	{0x5001 ,0x7f},
	{0x3503 ,0x00},
	{0x460c ,0x20},
	{0x460b ,0x37},
	{0x471c ,0xd0},
	{0x471d ,0x05},
	{0x3815 ,0x01},
	{0x3818 ,0xc0},
	{0x501f ,0x00},
	{0x5002 ,0xe0},
	{0x4300 ,0x32},
	{0x3002 ,0x1c},
	{0x4800 ,0x14},
	{0x4801 ,0x0f},
	{0x3007 ,0x3b},
	{0x300e ,0x04},
	{0x4803 ,0x50},
	{0x3815 ,0x01},
	{0x4713 ,0x02},
	{0x4842 ,0x01},
	/* 0x300f 2 lane*/
	{0x300f ,0x0e},
	{0x3003 ,0x03},
	{0x3003 ,0x01},

	{0xFFFF, 0xFF},
};

static struct regval_list ov5642_yuv_720p[] = {
	/*1 lane 720p yuv, 15fps*/
	{0x3103, 0x93},
	{0x3008, 0x82},
	{0x3017, 0x7f},
	{0x3018, 0xfc},
	{0x3810, 0xc2},
	{0x3615, 0xf0},
	{0x3000, 0x00},
	{0x3001, 0x00},
	{0x3002, 0x00},
	{0x3003, 0x00},
	{0x3004, 0xff},
	{0x3030, 0x0b},
	/*double sysclk, change from 0x8 to 0x10, change fps from 15fps to 30fps */
	/*{0x3011 ,0x08}, 15fps */
	{0x3011, 0x0F}, /* 30fps */
	{0x3010, 0x10},
	{0x3604, 0x60},
	{0x3622, 0x60},
	{0x3621, 0x09},
	{0x3709, 0x00},
	{0x4000, 0x21},
	{0x401d, 0x22},
	{0x3600, 0x54},
	{0x3605, 0x04},
	{0x3606, 0x3f},
	{0x3c01, 0x80},
	{0x300d, 0x22},
	{0x3623, 0x22},
	{0x5000, 0x4f},
	{0x5020, 0x04},
	{0x5181, 0x79},
	{0x5182, 0x00},
	{0x5185, 0x22},
	{0x5197, 0x01},
	{0x5500, 0x0a},
	{0x5504, 0x00},
	{0x5505, 0x7f},
	{0x5080, 0x08},
	{0x300e, 0x18},
	{0x4610, 0x00},
	{0x471d, 0x05},
	{0x4708, 0x06},
	{0x370c, 0xa0},
	{0x5687, 0x94},
	{0x501f, 0x00},
	{0x5000, 0x4f},
	{0x5001, 0xcf},
	{0x4300, 0x32},
	{0x4300, 0x32},
	{0x460b, 0x35},
	{0x471d, 0x00},
	{0x3002, 0x0c},
	{0x3002, 0x00},
	{0x4713, 0x03},
	{0x471c, 0x50},
	{0x4721, 0x02},
	{0x4402, 0x90},
	{0x460c, 0x22},
	{0x3815, 0x44},
	{0x3503, 0x07},
	{0x3501, 0x73},
	{0x3502, 0x80},
	{0x350b, 0x00},
	{0x3818, 0xc8},
	{0x3801, 0x88},
	{0x3824, 0x11},
	{0x3a00, 0x78},
	{0x3a1a, 0x04},
	{0x3a13, 0x30},
	{0x3a18, 0x00},
	{0x3a19, 0x7c},
	{0x3a08, 0x12},
	{0x3a09, 0xc0},
	{0x3a0a, 0x0f},
	{0x3a0b, 0xa0},
	{0x350c, 0x07},
	{0x350d, 0xd0},
	{0x3a0d, 0x08},
	{0x3a0e, 0x06},
	{0x3500, 0x00},
	{0x3501, 0x00},
	{0x3502, 0x00},
	{0x350a, 0x00},
	{0x350b, 0x00},
	{0x3503, 0x00},
	{0x3a0f, 0x3c},
	{0x3a10, 0x32},
	{0x3a1b, 0x3c},
	{0x3a1e, 0x32},
	{0x3a11, 0x80},
	{0x3a1f, 0x20},
	{0x3030, 0x0b},
	{0x3a02, 0x00},
	{0x3a03, 0x7d},
	{0x3a04, 0x00},
	{0x3a14, 0x00},
	{0x3a15, 0x7d},
	{0x3a16, 0x00},
	{0x3a00, 0x78},
	{0x3a08, 0x09},
	{0x3a09, 0x60},
	{0x3a0a, 0x07},
	{0x3a0b, 0xd0},
	{0x3a0d, 0x10},
	{0x3a0e, 0x0d},
	{0x4407, 0x04},
	{0x5193, 0x70},
	{0x589b, 0x00},
	{0x589a, 0xc0},
	{0x401e, 0x20},
	{0x4001, 0x42},
	{0x401c, 0x06},
	{0x3825, 0xac},
	{0x3827, 0x0c},
	{0x528a, 0x01},
	{0x528b, 0x04},
	{0x528c, 0x08},
	{0x528d, 0x10},
	{0x528e, 0x20},
	{0x528f, 0x28},
	{0x5290, 0x30},
	{0x5292, 0x00},
	{0x5293, 0x01},
	{0x5294, 0x00},
	{0x5295, 0x04},
	{0x5296, 0x00},
	{0x5297, 0x08},
	{0x5298, 0x00},
	{0x5299, 0x10},
	{0x529a, 0x00},
	{0x529b, 0x20},
	{0x529c, 0x00},
	{0x529d, 0x28},
	{0x529e, 0x00},
	{0x529f, 0x30},
	{0x5282, 0x00},
	{0x5300, 0x00},
	{0x5301, 0x20},
	{0x5302, 0x00},
	{0x5303, 0x7c},
	{0x530c, 0x00},
	{0x530d, 0x0c},
	{0x530e, 0x20},
	{0x530f, 0x80},
	{0x5310, 0x20},
	{0x5311, 0x80},
	{0x5308, 0x20},
	{0x5309, 0x40},
	{0x5304, 0x00},
	{0x5305, 0x30},
	{0x5306, 0x00},
	{0x5307, 0x80},
	{0x5314, 0x08},
	{0x5315, 0x20},
	{0x5319, 0x30},
	{0x5316, 0x10},
	{0x5317, 0x00},
	{0x5318, 0x02},
	{0x5380, 0x01},
	{0x5381, 0x00},
	{0x5382, 0x00},
	{0x5383, 0x4e},
	{0x5384, 0x00},
	{0x5385, 0x0f},
	{0x5386, 0x00},
	{0x5387, 0x00},
	{0x5388, 0x01},
	{0x5389, 0x15},
	{0x538a, 0x00},
	{0x538b, 0x31},
	{0x538c, 0x00},
	{0x538d, 0x00},
	{0x538e, 0x00},
	{0x538f, 0x0f},
	{0x5390, 0x00},
	{0x5391, 0xab},
	{0x5392, 0x00},
	{0x5393, 0xa2},
	{0x5394, 0x08},
	{0x5480, 0x14},
	{0x5481, 0x21},
	{0x5482, 0x36},
	{0x5483, 0x57},
	{0x5484, 0x65},
	{0x5485, 0x71},
	{0x5486, 0x7d},
	{0x5487, 0x87},
	{0x5488, 0x91},
	{0x5489, 0x9a},
	{0x548a, 0xaa},
	{0x548b, 0xb8},
	{0x548c, 0xcd},
	{0x548d, 0xdd},
	{0x548e, 0xea},
	{0x548f, 0x1d},
	{0x5490, 0x05},
	{0x5491, 0x00},
	{0x5492, 0x04},
	{0x5493, 0x20},
	{0x5494, 0x03},
	{0x5495, 0x60},
	{0x5496, 0x02},
	{0x5497, 0xb8},
	{0x5498, 0x02},
	{0x5499, 0x86},
	{0x549a, 0x02},
	{0x549b, 0x5b},
	{0x549c, 0x02},
	{0x549d, 0x3b},
	{0x549e, 0x02},
	{0x549f, 0x1c},
	{0x54a0, 0x02},
	{0x54a1, 0x04},
	{0x54a2, 0x01},
	{0x54a3, 0xed},
	{0x54a4, 0x01},
	{0x54a5, 0xc5},
	{0x54a6, 0x01},
	{0x54a7, 0xa5},
	{0x54a8, 0x01},
	{0x54a9, 0x6c},
	{0x54aa, 0x01},
	{0x54ab, 0x41},
	{0x54ac, 0x01},
	{0x54ad, 0x20},
	{0x54ae, 0x00},
	{0x54af, 0x16},
	{0x54b0, 0x01},
	{0x54b1, 0x20},
	{0x54b2, 0x00},
	{0x54b3, 0x10},
	{0x54b4, 0x00},
	{0x54b5, 0xf0},
	{0x54b6, 0x00},
	{0x54b7, 0xdf},
	{0x5402, 0x3f},
	{0x5403, 0x00},
	{0x3406, 0x00},
	{0x5180, 0xff},
	{0x5181, 0x52},
	{0x5182, 0x11},
	{0x5183, 0x14},
	{0x5184, 0x25},
	{0x5185, 0x24},
	{0x5186, 0x06},
	{0x5187, 0x08},
	{0x5188, 0x08},
	{0x5189, 0x7c},
	{0x518a, 0x60},
	{0x518b, 0xb2},
	{0x518c, 0xb2},
	{0x518d, 0x44},
	{0x518e, 0x3d},
	{0x518f, 0x58},
	{0x5190, 0x46},
	{0x5191, 0xf8},
	{0x5192, 0x04},
	{0x5193, 0x70},
	{0x5194, 0xf0},
	{0x5195, 0xf0},
	{0x5196, 0x03},
	{0x5197, 0x01},
	{0x5198, 0x04},
	{0x5199, 0x12},
	{0x519a, 0x04},
	{0x519b, 0x00},
	{0x519c, 0x06},
	{0x519d, 0x82},
	{0x519e, 0x00},
	{0x5025, 0x80},
	{0x3a0f, 0x38},
	{0x3a10, 0x30},
	{0x3a1b, 0x3a},
	{0x3a1e, 0x2e},
	{0x3a11, 0x60},
	{0x3a1f, 0x10},
	{0x5688, 0xa6},
	{0x5689, 0x6a},
	{0x568a, 0xea},
	{0x568b, 0xae},
	{0x568c, 0xa6},
	{0x568d, 0x6a},
	{0x568e, 0x62},
	{0x568f, 0x26},
	{0x5583, 0x40},
	{0x5584, 0x40},
	{0x5580, 0x02},
	{0x5000, 0xcf},
	{0x5800, 0x27},
	{0x5801, 0x19},
	{0x5802, 0x12},
	{0x5803, 0x0f},
	{0x5804, 0x10},
	{0x5805, 0x15},
	{0x5806, 0x1e},
	{0x5807, 0x2f},
	{0x5808, 0x15},
	{0x5809, 0x0d},
	{0x580a, 0x0a},
	{0x580b, 0x09},
	{0x580c, 0x0a},
	{0x580d, 0x0c},
	{0x580e, 0x12},
	{0x580f, 0x19},
	{0x5810, 0x0b},
	{0x5811, 0x07},
	{0x5812, 0x04},
	{0x5813, 0x03},
	{0x5814, 0x03},
	{0x5815, 0x06},
	{0x5816, 0x0a},
	{0x5817, 0x0f},
	{0x5818, 0x0a},
	{0x5819, 0x05},
	{0x581a, 0x01},
	{0x581b, 0x00},
	{0x581c, 0x00},
	{0x581d, 0x03},
	{0x581e, 0x08},
	{0x581f, 0x0c},
	{0x5820, 0x0a},
	{0x5821, 0x05},
	{0x5822, 0x01},
	{0x5823, 0x00},
	{0x5824, 0x00},
	{0x5825, 0x03},
	{0x5826, 0x08},
	{0x5827, 0x0c},
	{0x5828, 0x0e},
	{0x5829, 0x08},
	{0x582a, 0x06},
	{0x582b, 0x04},
	{0x582c, 0x05},
	{0x582d, 0x07},
	{0x582e, 0x0b},
	{0x582f, 0x12},
	{0x5830, 0x18},
	{0x5831, 0x10},
	{0x5832, 0x0c},
	{0x5833, 0x0a},
	{0x5834, 0x0b},
	{0x5835, 0x0e},
	{0x5836, 0x15},
	{0x5837, 0x19},
	{0x5838, 0x32},
	{0x5839, 0x1f},
	{0x583a, 0x18},
	{0x583b, 0x16},
	{0x583c, 0x17},
	{0x583d, 0x1e},
	{0x583e, 0x26},
	{0x583f, 0x53},
	{0x5840, 0x10},
	{0x5841, 0x0f},
	{0x5842, 0x0d},
	{0x5843, 0x0c},
	{0x5844, 0x0e},
	{0x5845, 0x09},
	{0x5846, 0x11},
	{0x5847, 0x10},
	{0x5848, 0x10},
	{0x5849, 0x10},
	{0x584a, 0x10},
	{0x584b, 0x0e},
	{0x584c, 0x10},
	{0x584d, 0x10},
	{0x584e, 0x11},
	{0x584f, 0x10},
	{0x5850, 0x0f},
	{0x5851, 0x0c},
	{0x5852, 0x0f},
	{0x5853, 0x10},
	{0x5854, 0x10},
	{0x5855, 0x0f},
	{0x5856, 0x0e},
	{0x5857, 0x0b},
	{0x5858, 0x10},
	{0x5859, 0x0d},
	{0x585a, 0x0d},
	{0x585b, 0x0c},
	{0x585c, 0x0c},
	{0x585d, 0x0c},
	{0x585e, 0x0b},
	{0x585f, 0x0c},
	{0x5860, 0x0c},
	{0x5861, 0x0c},
	{0x5862, 0x0d},
	{0x5863, 0x08},
	{0x5864, 0x11},
	{0x5865, 0x18},
	{0x5866, 0x18},
	{0x5867, 0x19},
	{0x5868, 0x17},
	{0x5869, 0x19},
	{0x586a, 0x16},
	{0x586b, 0x13},
	{0x586c, 0x13},
	{0x586d, 0x12},
	{0x586e, 0x13},
	{0x586f, 0x16},
	{0x5870, 0x14},
	{0x5871, 0x12},
	{0x5872, 0x10},
	{0x5873, 0x11},
	{0x5874, 0x11},
	{0x5875, 0x16},
	{0x5876, 0x14},
	{0x5877, 0x11},
	{0x5878, 0x10},
	{0x5879, 0x0f},
	{0x587a, 0x10},
	{0x587b, 0x14},
	{0x587c, 0x13},
	{0x587d, 0x12},
	{0x587e, 0x11},
	{0x587f, 0x11},
	{0x5880, 0x12},
	{0x5881, 0x15},
	{0x5882, 0x14},
	{0x5883, 0x15},
	{0x5884, 0x15},
	{0x5885, 0x15},
	{0x5886, 0x13},
	{0x5887, 0x17},
	{0x3710, 0x10},
	{0x3632, 0x51},
	{0x3702, 0x10},
	{0x3703, 0xb2},
	{0x3704, 0x18},
	{0x370b, 0x40},
	{0x370d, 0x03},
	{0x3631, 0x01},
	{0x3632, 0x52},
	{0x3606, 0x24},
	{0x3620, 0x96},
	{0x5785, 0x07},
	{0x3a13, 0x30},
	{0x3600, 0x52},
	{0x3604, 0x48},
	{0x3606, 0x1b},
	{0x370d, 0x0b},
	{0x370f, 0xc0},
	{0x3709, 0x01},
	{0x3823, 0x00},
	{0x5007, 0x00},
	{0x5009, 0x00},
	{0x5011, 0x00},
	{0x5013, 0x00},
	{0x519e, 0x00},
	{0x5086, 0x00},
	{0x5087, 0x00},
	{0x5088, 0x00},
	{0x5089, 0x00},
	{0x302b, 0x00},
	{0x3503, 0x07},
	/*double sysclk, change from 0x8 to 0x10, change fps from 15fps to 30fps */
	/*{0x3011 ,0x08}, 15fps */
	{0x3011, 0x0F}, /* 30fps */
	{0x350c, 0x02},
	{0x350d, 0xe4},
	{0x3621, 0xc9},
	{0x370a, 0x81},
	{0x3803, 0x08},
	{0x3804, 0x05},
	{0x3805, 0x00},
	{0x3806, 0x02},
	{0x3807, 0xd0},
	{0x3808, 0x05},
	{0x3809, 0x00},
	{0x380a, 0x02},
	{0x380b, 0xd0},
	{0x380c, 0x08},
	{0x380d, 0x72},
	{0x380e, 0x02},
	{0x380f, 0xe4},
	{0x3810, 0xc0},
	{0x3818, 0xc9},
	{0x381c, 0x10},
	{0x381d, 0xa0},
	{0x381e, 0x05},
	{0x381f, 0xb0},
	{0x3820, 0x00},
	{0x3821, 0x00},
	{0x3824, 0x11},
	{0x3a08, 0x1b},
	{0x3a09, 0xc0},
	{0x3a0a, 0x17},
	{0x3a0b, 0x20},
	{0x3a0d, 0x02},
	{0x3a0e, 0x01},
	{0x401c, 0x04},
	{0x5682, 0x05},
	{0x5683, 0x00},
	{0x5686, 0x02},
	{0x5687, 0xcc},
	{0x5001, 0x7f},
	{0x589b, 0x06},
	{0x589a, 0xc5},
	{0x3503, 0x00},
	{0x460c, 0x20},
	{0x460b, 0x37},
	{0x471c, 0xd0},
	{0x471d, 0x05},
	{0x3815, 0x01},
	{0x3818, 0xc1},
	{0x501f, 0x00},
	{0x5002, 0xe0},
	{0x4300, 0x32},
	{0x3002, 0x1c},
	{0x4800, 0x24},
	{0x4801, 0x0f},
	{0x3007, 0x3b},
	{0x300e, 0x04},
	{0x4803, 0x50},
	{0x3815, 0x01},
	{0x4713, 0x02},
	{0x4842, 0x01},
	{0x3029, 0x01},
	{0x300f, 0x0a},
	{0x3003, 0x03},
	{0x3003, 0x01},

	{0xFFFF, 0xFF},
};

/* JPEG, 5M resolution, 2592x1944*/
static struct regval_list __attribute__ ((unused)) ov5642_jpg[] = {

	{0x3103 , 0x93},
	{0x3008 , 0x82},
	{0x3017 , 0x7f},
	{0x3018 , 0xfc},
	{0x3810 , 0xc2},
	{0x3615 , 0xf0},
	{0x3000 , 0x00},
	{0x3001 , 0x00},
	{0x3002 , 0x00},
	{0x3003 , 0x00},
	{0x3030 , 0x2b},
	{0x3011 , 0x08},
	{0x3010 , 0x10},
	{0x3602 , 0xfc},
	{0x3603 , 0x27},
	{0x3604 , 0x40},
	{0x3612 , 0xff},
	{0x3613 , 0x00},
	{0x3622 , 0x60},
	{0x3621 , 0x09},
	{0x3709 , 0x00},
	{0x4000 , 0x21},
	{0x401d , 0x02},
	{0x3600 , 0x54},
	{0x3605 , 0x04},
	{0x3606 , 0x3f},
	{0x3c01 , 0x80},
	{0x300d , 0x21},
	{0x3623 , 0x22},
	{0x5000 , 0x4f},
	{0x5020 , 0x04},
	{0x5181 , 0x79},
	{0x5182 , 0x00},
	{0x5185 , 0x22},
	{0x5197 , 0x01},
	{0x5500 , 0x0a},
	{0x5504 , 0x00},
	{0x5505 , 0x7f},
	{0x5080 , 0x08},
	{0x300e , 0x18},
	{0x4610 , 0x00},
	{0x471d , 0x05},
	{0x4708 , 0x06},
	{0x3710 , 0x10},
	{0x3632 , 0x41},
	{0x3702 , 0x40},
	{0x3620 , 0x37},
	{0x3631 , 0x01},
	{0x370c , 0xa0},
	{0x3808 , 0x0a},
	{0x3809 , 0x20},
	{0x380a , 0x07},
	{0x380b , 0x98},
	{0x380c , 0x0c},
	{0x380d , 0x80},
	{0x380e , 0x07},
	{0x380f , 0xd0},
	{0x3801 , 0x8a},
	{0x501f , 0x00},
	{0x5000 , 0x4f},
	{0x5001 , 0xcf},
	{0x4300 , 0x30},
	{0x4300 , 0x30},
	{0x460b , 0x35},
	{0x471d , 0x00},
	{0x3002 , 0x0c},
	{0x3002 , 0x00},
	{0x4713 , 0x03},
	{0x471c , 0x50},
	{0x4721 , 0x02},
	{0x4402 , 0x90},
	{0x460c , 0x22},
	{0x3815 , 0x44},
	{0x3503 , 0x07},
	{0x3501 , 0x73},
	{0x3502 , 0x80},
	{0x350b , 0x00},
	{0x3818 , 0xc8},
	{0x3824 , 0x11},
	{0x3801 , 0x8a},
	{0x3a00 , 0x78},
	{0x3a1a , 0x04},
	{0x3a13 , 0x30},
	{0x3a18 , 0x00},
	{0x3a19 , 0x7c},
	{0x3a08 , 0x12},
	{0x3a09 , 0xc0},
	{0x3a0a , 0x0f},
	{0x3a0b , 0xa0},
	{0x3004 , 0xff},
	{0x350c , 0x07},
	{0x350d , 0xd0},
	{0x3a0d , 0x08},
	{0x3a0e , 0x06},
	{0x3500 , 0x00},
	{0x3501 , 0x00},
	{0x3502 , 0x00},
	{0x350a , 0x00},
	{0x350b , 0x00},
	{0x3503 , 0x00},
	{0x3a0f , 0x3c},
	{0x3a10 , 0x32},
	{0x3a1b , 0x3c},
	{0x3a1e , 0x32},
	{0x3a11 , 0x80},
	{0x3a1f , 0x20},
	{0x3030 , 0x0b},
	{0x3a02 , 0x00},
	{0x3a03 , 0x7d},
	{0x3a04 , 0x00},
	{0x3a14 , 0x00},
	{0x3a15 , 0x7d},
	{0x3a16 , 0x00},
	{0x3a00 , 0x78},
	{0x3a08 , 0x09},
	{0x3a09 , 0x60},
	{0x3a0a , 0x07},
	{0x3a0b , 0xd0},
	{0x3a0d , 0x10},
	{0x3a0e , 0x0d},
	{0x4407 , 0x04},
	{0x5193 , 0x70},
	{0x3620 , 0x57},
	{0x3703 , 0x98},
	{0x3704 , 0x1c},
	{0x589b , 0x00},
	{0x589a , 0xc0},
	{0x528a , 0x00},
	{0x528b , 0x02},
	{0x528c , 0x08},
	{0x528d , 0x10},
	{0x528e , 0x20},
	{0x528f , 0x28},
	{0x5290 , 0x30},
	{0x5292 , 0x00},
	{0x5293 , 0x00},
	{0x5294 , 0x00},
	{0x5295 , 0x02},
	{0x5296 , 0x00},
	{0x5297 , 0x08},
	{0x5298 , 0x00},
	{0x5299 , 0x10},
	{0x529a , 0x00},
	{0x529b , 0x20},
	{0x529c , 0x00},
	{0x529d , 0x28},
	{0x529e , 0x00},
	{0x529f , 0x30},
	{0x5282 , 0x00},
	{0x5300 , 0x00},
	{0x5301 , 0x20},
	{0x5302 , 0x00},
	{0x5303 , 0x7c},
	{0x530c , 0x00},
	{0x530d , 0x0c},
	{0x530e , 0x20},
	{0x530f , 0x80},
	{0x5310 , 0x20},
	{0x5311 , 0x80},
	{0x5308 , 0x20},
	{0x5309 , 0x40},
	{0x5304 , 0x00},
	{0x5305 , 0x30},
	{0x5306 , 0x00},
	{0x5307 , 0x80},
	{0x5314 , 0x08},
	{0x5315 , 0x20},
	{0x5319 , 0x30},
	{0x5316 , 0x10},
	{0x5317 , 0x08},
	{0x5318 , 0x02},
	{0x5380 , 0x01},
	{0x5381 , 0x00},
	{0x5382 , 0x00},
	{0x5383 , 0x4e},
	{0x5384 , 0x00},
	{0x5385 , 0x0f},
	{0x5386 , 0x00},
	{0x5387 , 0x00},
	{0x5388 , 0x01},
	{0x5389 , 0x15},
	{0x538a , 0x00},
	{0x538b , 0x31},
	{0x538c , 0x00},
	{0x538d , 0x00},
	{0x538e , 0x00},
	{0x538f , 0x0f},
	{0x5390 , 0x00},
	{0x5391 , 0xab},
	{0x5392 , 0x00},
	{0x5393 , 0xa2},
	{0x5394 , 0x08},
	{0x5480 , 0x14},
	{0x5481 , 0x21},
	{0x5482 , 0x36},
	{0x5483 , 0x57},
	{0x5484 , 0x65},
	{0x5485 , 0x71},
	{0x5486 , 0x7d},
	{0x5487 , 0x87},
	{0x5488 , 0x91},
	{0x5489 , 0x9a},
	{0x548a , 0xaa},
	{0x548b , 0xb8},
	{0x548c , 0xcd},
	{0x548d , 0xdd},
	{0x548e , 0xea},
	{0x548f , 0x10},
	{0x5490 , 0x05},
	{0x5491 , 0x00},
	{0x5492 , 0x04},
	{0x5493 , 0x20},
	{0x5494 , 0x03},
	{0x5495 , 0x60},
	{0x5496 , 0x02},
	{0x5497 , 0xb8},
	{0x5498 , 0x02},
	{0x5499 , 0x86},
	{0x549a , 0x02},
	{0x549b , 0x5b},
	{0x549c , 0x02},
	{0x549d , 0x3b},
	{0x549e , 0x02},
	{0x549f , 0x1c},
	{0x54a0 , 0x02},
	{0x54a1 , 0x04},
	{0x54a2 , 0x01},
	{0x54a3 , 0xed},
	{0x54a4 , 0x01},
	{0x54a5 , 0xc5},
	{0x54a6 , 0x01},
	{0x54a7 , 0xa5},
	{0x54a8 , 0x01},
	{0x54a9 , 0x6c},
	{0x54aa , 0x01},
	{0x54ab , 0x41},
	{0x54ac , 0x01},
	{0x54ad , 0x20},
	{0x54ae , 0x00},
	{0x54af , 0x16},
	{0x3406 , 0x00},
	{0x5192 , 0x04},
	{0x5191 , 0xf8},
	{0x5193 , 0x70},
	{0x5194 , 0xf0},
	{0x5195 , 0xf0},
	{0x518d , 0x3d},
	{0x518f , 0x54},
	{0x518e , 0x3d},
	{0x5190 , 0x54},
	{0x518b , 0xc0},
	{0x518c , 0xbd},
	{0x5187 , 0x18},
	{0x5188 , 0x18},
	{0x5189 , 0x6e},
	{0x518a , 0x68},
	{0x5186 , 0x1c},
	{0x5181 , 0x50},
	{0x5184 , 0x25},
	{0x5182 , 0x11},
	{0x5183 , 0x14},
	{0x5184 , 0x25},
	{0x5185 , 0x24},
	{0x5025 , 0x82},
	{0x3a0f , 0x7e},
	{0x3a10 , 0x72},
	{0x3a1b , 0x80},
	{0x3a1e , 0x70},
	{0x3a11 , 0xd0},
	{0x3a1f , 0x40},
	{0x5583 , 0x40},
	{0x5584 , 0x40},
	{0x5580 , 0x02},
	{0x3633 , 0x07},
	{0x3702 , 0x10},
	{0x3703 , 0xb2},
	{0x3704 , 0x18},
	{0x370b , 0x40},
	{0x370d , 0x02},
	{0x3620 , 0x52},
	{0x4801 , 0x0f},
	{0x3007 , 0x3b},
	{0x300e , 0x04},
	{0x4803 , 0x50},
	{0x3815 , 0x01},
	{0x4713 , 0x02},
	{0x4842 , 0x01},
	{0x300f , 0x0a},
	{0x3010 , 0x11},
	{0x3009 , 0x84},
	{0x460c , 0x82},
	{0x3003 , 0x03},
	{0x3003 , 0x01},

	/* clock set */
	{0x3011 , 0x07},
	{0x3010 , 0x11},

	/* flip and mirror */
	{0x3818, 0xa8},
	{0x3621, 0x29},

	/* clock gating whock lane when no packet to transmit */
	{0x4800 , 0x24},

	/* power down until stream on  */
	{0x3008 , 0x40},

	{0xFFFF, 0xFF}
};


static struct regval_list ov5642_fmt_jpg[] = {

	{0x460c , 0x22},/* manual */
	{0x460b , 0x35},
	{0x471d , 0x00},
	{0x3002 , 0x0c},
	{0x3002 , 0x00},
	{0x4713 , 0x03},/* jpeg modei 2 */
	{0x471c , 0x50},
	{0x3815 , 0x44},
	{0x3818 , 0xc9},/* JPG en */

	{0x3006 , 0xff},
	{0x3007 , 0x3f},
	END_SIGN
};

static struct regval_list ov5642_res_5M[] = {
	/* 2592 x 1944 */
	{0x5001 , 0xcf},
	{0x3808 , 0x0a},
	{0x3809 , 0x20},
	{0x380a , 0x07},
	{0x380b , 0x98},
	END_SIGN
};

static struct regval_list __attribute((unused)) ov5642_res_1080P[] = {
	/* 1920x1080 */
	{0x5001, 0xff},
	{0x3808 ,0x07},
	{0x3809 ,0x80},
	{0x380a ,0x04},
	{0x380b ,0x38},

	{0xFFFF, 0xFF}
};

static struct regval_list __attribute((unused)) ov5642_res_720P[] = {
	/* 1280x720 */
	{0x5001, 0xff},
	{0x3808 ,0x05},
	{0x3809 ,0x00},
	{0x380a ,0x02},
	{0x380b ,0xd0},

	{0xFFFF, 0xFF}
};

static struct regval_list __attribute((unused)) ov5642_res_vga_v[] = {
	/* 480 x 640 */
	{0x3808, 0x01},
	{0x3809, 0xe0},
	{0x380a, 0x02},
	{0x380b, 0x80},
	END_SIGN
};
static struct regval_list ov5642_res_vga[] = {
	/* 640 x 480 */
	{0x5001, 0xff},
	{0x3808, 0x02},
	{0x3809, 0x80},
	{0x380a, 0x01},
	{0x380b, 0xe0},
	END_SIGN
};

static struct regval_list ov5642_res_wvga[] = {
	/* 800 x 480 */
	{0x5001, 0xff},
	{0x3808, 0x03},
	{0x3809, 0x20},
	{0x380a, 0x01},
	{0x380b, 0xe0},
	END_SIGN
};
static struct regval_list __attribute((unused)) ov5642_res_half_vga_v[] = {
	/* 320 x 480 */
	{0x3808, 0x01},
	{0x3809, 0x40},
	{0x380a, 0x01},
	{0x380b, 0xe0},

	{0xFFFF, 0xFF}
};

static struct regval_list __attribute((unused)) ov5642_res_half_vga[] = {
	/* 480 x 320 */
	{0x5001, 0xff},
	{0x3808, 0x01},
	{0x3809, 0xe0},
	{0x380a, 0x01},
	{0x380b, 0x40},

	{0xFFFF, 0xFF}
};

static struct regval_list __attribute((unused)) ov5642_res_qvga_v[] = {
	/* 240 x 320 */
	{0x3808, 0x00},
	{0x3809, 0xf0},
	{0x380a, 0x01},
	{0x380b, 0x40},

	{0xFFFF, 0xFF}
};
static struct regval_list ov5642_res_qvga[] = {
	/* 320 x 240 */
	{0x5001, 0xff},
	{0x3808, 0x01},
	{0x3809, 0x40},
	{0x380a, 0x00},
	{0x380b, 0xf0},
	END_SIGN
};

static struct regval_list ov5642_res_cif[] = {
        /* 352 x 288 */
        {0x5001, 0xff},
        {0x3808, 0x01},
        {0x3809, 0x60},
        {0x380a, 0x01},
        {0x380b, 0x20},
	END_SIGN
};

static struct regval_list ov5642_res_qcif[] = {
        /* 176 x 144 */
        {0x5001, 0xff},
        {0x3808, 0x00},
        {0x3809, 0xB0},
        {0x380a, 0x00},
        {0x380b, 0x90},
	END_SIGN
};

static struct regval_list ov5642_fmt_default[] = {
	/*     Addr  , Data   */
	{0x3103, 0x93},
	{0x3008, 0x02},
	{0x3017, 0x7f},
	{0x3018, 0xfc},
	{0x3810, 0xc2},
	{0x3615, 0xf0},
	{0x3000, 0x00},
	{0x3001, 0x00},
	{0x3002, 0x00},
	{0x3003, 0x00},
	{0x3000, 0xf8},
	{0x3001, 0x48},
	{0x3002, 0x5c},
	{0x3003, 0x02},
	{0x3004, 0x07},
	{0x3005, 0xb7},
	{0x3006, 0x43},
	{0x3007, 0x37},

	/* PLL 26Mhz91Mhz */
	{0x3011, 0x07},
	{0x3010, 0x00},

	{0x460c, 0x22},


	{0x370c, 0xa0},
	{0x3602, 0xfc},
	{0x3612, 0xff},
	{0x3634, 0xc0},
	{0x3613, 0x00},
	{0x3605, 0x7c},
	{0x3621, 0x09},
	{0x3622, 0x00},
	{0x3604, 0x40},
	{0x3603, 0xa7},
	{0x3603, 0x27},
	{0x4000, 0x21},
	{0x401d, 0x02},
	{0x3600, 0x54},
	{0x3605, 0x04},
	{0x3606, 0x3f},
	{0x3c01, 0x80},
	{0x5000, 0x4f},
	{0x5020, 0x04},
	{0x5181, 0x79},
	{0x5182, 0x00},
	{0x5185, 0x22},
	{0x5197, 0x01},
	{0x5001, 0xff},
	{0x5500, 0x0a},
	{0x5504, 0x00},
	{0x5505, 0x7f},
	{0x5080, 0x08},
	{0x300e, 0x18},
	{0x4610, 0x00},
	{0x471d, 0x05},
	{0x4708, 0x06},
	{0x3710, 0x10},
	{0x3632, 0x41},
	{0x3702, 0x40},
	{0x3620, 0x37},
	{0x3631, 0x01},

	{0x380e, 0x07},
	{0x380f, 0xd0},

	{0x5000, 0x4f},
	{0x3503, 0x07},
	{0x3501, 0x73},
	{0x3502, 0x80},
	{0x350b, 0x00},
	{0x3503, 0x07},
	{0x3824, 0x11},
	{0x3501, 0x1e},
	{0x3502, 0x80},
	{0x350b, 0x7f},

	{0x380c, 0x0c},
	{0x380d, 0x80},

	{0x380e, 0x03},
	{0x380f, 0xe8},

	{0x3a0d, 0x04},
	{0x3a0e, 0x03},
	{0x3818, 0xc1},
	{0x3705, 0xdb},
	{0x370a, 0x81},
	{0x3801, 0x80},
	{0x3621, 0xc7},
	{0x3801, 0x50},
	{0x3803, 0x08},
	{0x3827, 0x08},
	{0x3810, 0xc0},
	{0x3804, 0x05},
	{0x3805, 0x00},
	{0x5682, 0x05},
	{0x5683, 0x00},
	{0x3806, 0x03},
	{0x3807, 0xc0},
	{0x5686, 0x03},
	{0x5687, 0xb8},
	{0x3a00, 0x78},
	{0x3a1a, 0x04},
	{0x3a13, 0x30},
	{0x3a18, 0x00},
	{0x3a19, 0x7c},
	{0x3a08, 0x12},
	{0x3a09, 0xc0},
	{0x3a0a, 0x0f},
	{0x3a0b, 0xa0},
	{0x3004, 0xff},
	{0x350c, 0x07},
	{0x350d, 0xd0},
	{0x3500, 0x00},
	{0x3501, 0x00},
	{0x3502, 0x00},
	{0x350a, 0x00},
	{0x350b, 0x00},
	{0x3503, 0x00},
	{0x528a, 0x02},
	{0x528b, 0x04},
	{0x528c, 0x08},
	{0x528d, 0x08},
	{0x528e, 0x08},
	{0x528f, 0x10},
	{0x5290, 0x10},
	{0x5292, 0x00},
	{0x5293, 0x02},
	{0x5294, 0x00},
	{0x5295, 0x02},
	{0x5296, 0x00},
	{0x5297, 0x02},
	{0x5298, 0x00},
	{0x5299, 0x02},
	{0x529a, 0x00},
	{0x529b, 0x02},
	{0x529c, 0x00},
	{0x529d, 0x02},
	{0x529e, 0x00},
	{0x529f, 0x02},
	{0x3a0f, 0x3c},
	{0x3a10, 0x30},
	{0x3a1b, 0x3c},
	{0x3a1e, 0x30},
	{0x3a11, 0x70},
	{0x3a1f, 0x10},
	{0x3030, 0x0b},
	{0x3a02, 0x00},
	{0x3a03, 0x7d},
	{0x3a04, 0x00},
	{0x3a14, 0x00},
	{0x3a15, 0x7d},
	{0x3a16, 0x00},
	{0x3a08, 0x09},
	{0x3a09, 0x60},
	{0x3a0a, 0x07},
	{0x3a0b, 0xd0},
	{0x3a0d, 0x08},
	{0x3a0e, 0x06},
	{0x5193, 0x70},
	{0x3620, 0x57},
	{0x3703, 0x98},
	{0x3704, 0x1c},
	{0x589b, 0x04},
	{0x589a, 0xc5},
	{0x528a, 0x00},
	{0x528b, 0x02},
	{0x528c, 0x08},
	{0x528d, 0x10},
	{0x528e, 0x20},
	{0x528f, 0x28},
	{0x5290, 0x30},
	{0x5292, 0x00},
	{0x5293, 0x00},
	{0x5294, 0x00},
	{0x5295, 0x02},
	{0x5296, 0x00},
	{0x5297, 0x08},
	{0x5298, 0x00},
	{0x5299, 0x10},
	{0x529a, 0x00},
	{0x529b, 0x20},
	{0x529c, 0x00},
	{0x529d, 0x28},
	{0x529e, 0x00},
	{0x529f, 0x30},
	{0x5282, 0x00},
	{0x5300, 0x00},
	{0x5301, 0x20},
	{0x5302, 0x00},
	{0x5303, 0x7c},
	{0x530c, 0x00},
	{0x530d, 0x0c},
	{0x530e, 0x20},
	{0x530f, 0x80},
	{0x5310, 0x20},
	{0x5311, 0x80},
	{0x5308, 0x20},
	{0x5309, 0x40},
	{0x5304, 0x00},
	{0x5305, 0x30},
	{0x5306, 0x00},
	{0x5307, 0x80},
	{0x5314, 0x08},
	{0x5315, 0x20},
	{0x5319, 0x30},
	{0x5316, 0x10},
	{0x5317, 0x08},
	{0x5318, 0x02},
	{0x5380, 0x01},
	{0x5381, 0x00},
	{0x5382, 0x00},
	{0x5383, 0x4e},
	{0x5384, 0x00},
	{0x5385, 0x0f},
	{0x5386, 0x00},
	{0x5387, 0x00},
	{0x5388, 0x01},
	{0x5389, 0x15},
	{0x538a, 0x00},
	{0x538b, 0x31},
	{0x538c, 0x00},
	{0x538d, 0x00},
	{0x538e, 0x00},
	{0x538f, 0x0f},
	{0x5390, 0x00},
	{0x5391, 0xab},
	{0x5392, 0x00},
	{0x5393, 0xa2},
	{0x5394, 0x08},
	{0x5480, 0x14},
	{0x5481, 0x21},
	{0x5482, 0x36},
	{0x5483, 0x57},
	{0x5484, 0x65},
	{0x5485, 0x71},
	{0x5486, 0x7d},
	{0x5487, 0x87},
	{0x5488, 0x91},
	{0x5489, 0x9a},
	{0x548a, 0xaa},
	{0x548b, 0xb8},
	{0x548c, 0xcd},
	{0x548d, 0xdd},
	{0x548e, 0xea},
	{0x548f, 0x10},
	{0x5490, 0x05},
	{0x5491, 0x00},
	{0x5492, 0x04},
	{0x5493, 0x20},
	{0x5494, 0x03},
	{0x5495, 0x60},
	{0x5496, 0x02},
	{0x5497, 0xb8},
	{0x5498, 0x02},
	{0x5499, 0x86},
	{0x549a, 0x02},
	{0x549b, 0x5b},
	{0x549c, 0x02},
	{0x549d, 0x3b},
	{0x549e, 0x02},
	{0x549f, 0x1c},
	{0x54a0, 0x02},
	{0x54a1, 0x04},
	{0x54a2, 0x01},
	{0x54a3, 0xed},
	{0x54a4, 0x01},
	{0x54a5, 0xc5},
	{0x54a6, 0x01},
	{0x54a7, 0xa5},
	{0x54a8, 0x01},
	{0x54a9, 0x6c},
	{0x54aa, 0x01},
	{0x54ab, 0x41},
	{0x54ac, 0x01},
	{0x54ad, 0x20},
	{0x54ae, 0x00},
	{0x54af, 0x16},
	{0x3406, 0x00},
	{0x5192, 0x04},
	{0x5191, 0xf8},
	{0x5193, 0x70},
	{0x5194, 0xf0},
	{0x5195, 0xf0},
	{0x518d, 0x3d},
	{0x518f, 0x54},
	{0x518e, 0x3d},
	{0x5190, 0x54},
	{0x518b, 0xc0},
	{0x518c, 0xbd},
	{0x5187, 0x18},
	{0x5188, 0x18},
	{0x5189, 0x6e},
	{0x518a, 0x68},
	{0x5186, 0x1c},
	{0x5181, 0x50},
	{0x5184, 0x25},
	{0x5182, 0x11},
	{0x5183, 0x14},
	{0x5184, 0x25},
	{0x5185, 0x24},
	{0x5025, 0x82},
	{0x3a0f, 0x7e},
	{0x3a10, 0x72},
	{0x3a1b, 0x80},
	{0x3a1e, 0x70},
	{0x3a11, 0xd0},
	{0x3a1f, 0x40},
	{0x5583, 0x40},
	{0x5584, 0x40},
	{0x5580, 0x02},
	{0x3633, 0x07},
	{0x3702, 0x10},
	{0x3703, 0xb2},
	{0x3704, 0x18},
	{0x370b, 0x40},
	{0x370d, 0x02},
	{0x3620, 0x52},

	/* flip and mirror */
	{0x3818, 0xa1},
	{0x3621, 0xa7},

	/* clock set */
	{0x3011 , 0x09},
	{0x3010 , 0x11},

	/*binning */
	{0x380c, 0x07},
	{0x380d, 0x0a},
	{0x3815, 0x03},

	/* clock gating whock lane when no packet to transmit */
	{0x4800 , 0x24},

	/* power down until stream on  */
	{0x3008 , 0x40},

	{0xFFFF, 0xFF}
};

static struct regval_list ov5642_mipi[] = {

	{0x4801, 0x0f},
	{0x3007, 0x3b},
	{0x300e, 0x04},
	{0x4803, 0x50},
	{0x4713, 0x02},
	{0x4842, 0x01},
	{0x3003, 0x03},
	{0x3003, 0x01},

	/* 1 lane */
	{0x3033, 0x43},
	{0x300f, 0x0a},

	/* 2 lane */
	/*
	{0x300f, 0x0e},
	*/
	END_SIGN
};

static struct regval_list ov5642_jpg_no_reset[] = {

	{0x3503, 0x07}, /* AEC: AEC/AGC/CTS->manual */
	{0x3005, 0xff}, /* CLK_EN_1: EN:ALL */
	{0x3006, 0xff}, /* CLK_EN_2: EN:ALL */
	{0x3602, 0xe4}, /* ??? */
	{0x3603, 0x27}, /* ??? */
	{0x3604, 0x60}, /* ??? */
	{0x3612, 0xac}, /* ??? */
	{0x3613, 0x44}, /* ??? */
	{0x3622, 0x08}, /* ??? */
	{0x3623, 0x22}, /* ??? */
	{0x3621, 0x27}, /* ARRAY CTRL	Horizol binning disable */
	{0x3705, 0xda}, /* ?? */
	{0x370a, 0x80}, /* ?? */
	{0x3810, 0xc2}, /* TIMING_HVOFFS 7:4,3:0->H,V */
	{0x3a0d, 0x10}, /* AEC_CTRL_D */
	{0x3a0e, 0x0d}, /* AEC_CTRL_E */
	{0x3a00, 0x78}, /* AEC_CTRL_0 */
	{0x5682, 0x0a}, /* AVG_X_END_HIGH */
	{0x5683, 0x20}, /* AVG_X_END_LOW */
	{0x5686, 0x07}, /* AVG_Y_END_HIGH */
	{0x5687, 0x98}, /* AVG_Y_END_LOW */
	{0x589b, 0x00}, /* ??? */
	{0x589a, 0xc0}, /* ??? */
	{0x4600, 0x80}, /* VFIFO_CTRL0 */
	{0x4721, 0x02}, /* ??? */
	{0x4408, 0x00}, /* COMPRESSION_ISI_CTRL */
	{0x440a, 0x01}, /* COMPRESSION_CTRL_A */
	{0x4402, 0x90}, /* COMPRESSION_CTRL_2 */
	{0x3811, 0xf0}, /* TIMING_THNHV thumbnail */
	{0x4602, 0x06}, /* VFIFO_HW H */
	{0x4603, 0x00}, /* VFIFO_HW L */
	{0x4604, 0x07}, /* VFIFO_VH H */
	{0x4605, 0x98}, /* VFIFO_VH L */
	{0x350c, 0x07}, /* AEC_PK_VTS_H */
	{0x350d, 0xd0}, /* AEC_PK_VTS_L */
	{0x3800, 0x01}, /* TIMING_HS	HREF horizontal start high */
	{0x3801, 0x8a}, /* TIMING_HS	HREF horizontal start low */
	{0x3802, 0x00}, /* TIMING_VS	HREF vertical start high */
	{0x3803, 0x0a}, /* TIMING_VS	HREF vertical start low */
	{0x3819, 0x80}, /* ??? */
	{0x5001, 0xcf}, /* ISP_CTRL1 */
	{0x4801, 0x0f}, /* MIPI_CTRL1 */
	{0x3007, 0x3b}, /* CLK_EN3	Enable MIPI clock */
	{0x300e, 0x04}, /* MIPI_CTRL0:	MIPI PHY POWER UP, MIPI ENABLE */
	{0x4803, 0x50}, /* MIPI_CTRL3:	disable LP CD */
	{0x4713, 0x02}, /* COMPRESS_MODE 2 */
	{0x4842, 0x01}, /* RSVD */
	{0x3003, 0x03}, /* SYS_RST3:	reset MIPI/DVP */
	{0x3003, 0x01}, /* SYS_RST3:	reset DVP */
	{0x4800, 0x04}, /* MIPI_CTRL0:	LP11 idle */
	{0x3029, 0x00}, /* ??? */
	{0x3009, 0x84}, /* MIPI_CLK_DIVDR */
	{0x3827, 0x11}, /* ??? */
	{0x3804, 0x0A}, /* TIMING_HW	HREF horizontal width high */
	{0x3805, 0x20}, /* TIMING_HW	HREF horizontal width low */
	{0x3806, 0x07}, /* TIMING_VH	HREF vertical height high */
	{0x3807, 0x98}, /* TIMING_VH	HREF vertical height low */
	{0x3808, 0x0a}, /* TIMING_HO	DVP horizontal width high */
	{0x3809, 0x20}, /* TIMING_HO	DVP horizontal width low */
	{0x380A, 0x07}, /* TIMING_VO	DVP vertical height high */
	{0x380B, 0x98}, /* TIMING_VO	DVP vertical height low */
	{0x380C, 0x0C}, /* TIMING_HTS */
	{0x380D, 0x80}, /* TIMING_HTS */
	{0x380E, 0x07}, /* TIMING_VTS */
	{0x380F, 0xD0}, /* TIMING_VTS */
	{0x460c, 0x82}, /* VFIFO_CTRL0C */
	{0x460b, 0x35}, /* VFIFO_CTRL0C */
	{0x471c, 0x50}, /* RSVD */
	{0x471d, 0x00}, /* RSVD */
	{0x3815, 0x01}, /* ??? */
	{0x3818, 0xc8}, /* TIMING_CTRL8 Mirror compress enabled */
	{0x501f, 0x00}, /* FORMAT_MUX */
	{0x5002, 0xe0}, /* ISP_CTRL2 */
	{0x4300, 0x30}, /* FORMAT_CTRL3: YUV422 */
	{0x3002, 0x00}, /* SYS_RST_2: unreset NONE */
	{0x4800, 0x24}, /* MIPI_CTRL_0:	clock free run */
	{0x3029, 0x00}, /* RSVD */
	{0x3033, 0x03}, /* RSVD */
	{0x300F, 0x0A}, /* PLL_CTRL0 */
	{0x3010, 0x11}, /* PLL */
	{0x3009, 0x84}, /* MIPI_CLK_DIVDR */
	END_SIGN
};

static struct regval_list ov5642_preview_no_reset[] = {

	{0x3503, 0x00},	/* AEC_PK_MAN: AEC/AGC/CTS->auto */
	{0x3005, 0xb7}, /* CLK_EN_1: AFC/CIF->clock off */
	{0x3006, 0x43}, /* CLK_EN_2: compress related->clock off */
	{0x3602, 0xfc}, /* ??? */
	{0x3604, 0x40}, /* ??? */
	{0x3612, 0xff}, /* ??? */
	{0x3613, 0x00}, /* ??? */
	{0x3622, 0x00}, /* ??? */
	{0x3623, 0x01}, /* ??? */
	{0x3621, 0xa7}, /* ARRAY_CTRL_1	Horizol binning enable */
	{0x3705, 0xdb}, /* ??? */
	{0x370a, 0x81}, /* ??? */
	{0x3810, 0xc0}, /* TIMING_HVOFFS 7:4,3:0->H,V */
	{0x3a0d, 0x08}, /* AEC_CTRL_D */
	{0x3a0e, 0x06}, /* AEC_CTRL_E */
	{0x5682, 0x05}, /* AVG_X_END_H */
	{0x5683, 0x00}, /* AVG_X_END_L */
	{0x5686, 0x03}, /* AVG_Y_END_H */
	{0x5687, 0xb8}, /* AVG_Y_END_L */
	{0x589b, 0x04}, /* ??? */
	{0x589a, 0xc5}, /* ??? */
	{0x4721, 0x01}, /* ??? */
	{0x440a, 0x4e}, /* COMPRESSION_CTRL_A */
	{0x4402, 0x10}, /* COMPRESSION_CTRL_2 */
	{0x4602, 0x04}, /* VFIFO_HW H */
	{0x4604, 0x03}, /* VFIFO_VH H */
	{0x4605, 0x00}, /* VFIFO_VH L */
	{0x350c, 0x03}, /* AEC_PK_VTS_H */
	{0x350d, 0xe8}, /* AEC_PK_VTS_L */
	{0x3801, 0x50}, /* TIMING_HS	HREF horizontal start low */
	{0x3803, 0x08}, /* TIMING_HS	HREF vertical start low */
	{0x5001, 0xff}, /* ISP_CTRL_1: V/H scaling disable */
	{0x3003, 0x01}, /* SYS_RST_3:	reset DVP */
	{0x3009, 0x84}, /* MIPI_CLK_DIVIDER */
	{0x3827, 0x08}, /* ??? */
	{0x3804, 0x05}, /* TIMING_HW	HREF horizontal width high */
	{0x3805, 0x00}, /* TIMING_HW	HREF horizontal width low */
	{0x3806, 0x03}, /* TIMING_VH	HREF vertical height high */
	{0x3807, 0xc0}, /* TIMING_VH	HREF vertical height low */
	{0x3808, 0x02}, /* TIMING_HO	DVP horizontal width high */
	{0x3809, 0x80}, /* TIMING_HO	DVP horizontal width low */
	{0x380A, 0x01}, /* TIMING_VO	DVP vertical height high */
	{0x380B, 0xe0}, /* TIMING_VO	DVP vertical height low */
	{0x380C, 0x07}, /* TIMING_HTS */
	{0x380D, 0x0a}, /* TIMING_HTS */
	{0x380E, 0x03}, /* TIMING_VTS */
	{0x380F, 0xe8}, /* TIMING_VTS */
	{0x460c, 0x22}, /* VFIFO_CTRL0C */
	{0x460b, 0x37}, /* VFIFO_CTRL0C */
	{0x471c, 0xd0}, /* RSVD */
	{0x471d, 0x05}, /* RSVD */
	{0x3815, 0x03}, /* ??? */
	{0x3818, 0xa1}, /* TIMING_CTRL8 Mirror compress enabled */
	{0x3002, 0x5c}, /* SYS_RST_2: reset compress related */
	{0x4800, 0x24}, /* MIPI_CTRL_0:	clock gate */
	{0x3033, 0x43}, /* RSVD */
	{0x3009, 0x01}, /* MIPI_CL K_DIVIDER */
	END_SIGN
};

/*
 * Low-level register I/O.
 */
/*issue that OV sensor must write then read. 5642 register is 16bit!!!*/
static int ov5642_read(struct i2c_client *c, u16 reg,
		unsigned char *value)
{
	u8 data;
	u8 address[2];
	int ret = 0;
	address[0] = reg>>8;
	address[1] = reg;
	ret = i2c_smbus_write_byte_data(c,address[0],address[1]);
	if (ret)
		goto exit;
	data = i2c_smbus_read_byte(c);
	*value = data;
exit:
	return ret;
}


static int ov5642_write(struct i2c_client *c, u16 reg,
		unsigned char value)
{
	u8 data[3];
	data[0] = reg>>8;
	data[1] = reg;
	data[2]=  value;
	i2c_master_send(c, data, 3);
	if (reg == REG_SYSCTRL && (value & SW_RESET)) {
		printk(KERN_WARNING "cam: a S/W reset triggered, may result in register value lost\n");
		msleep(2);  /* Wait for reset to run */
	}
	return 0;
}


/*
 * Write a list of register settings; ff/ff stops the process.
 */
static int ov5642_write_array(struct i2c_client *c, struct regval_list *vals)
{
	while (vals->reg_num != 0xffff || vals->value != 0xff) {
		int ret = ov5642_write(c, vals->reg_num, vals->value);
		if (ret < 0)
			return ret;
		vals++;
	}
	return 0;
}

/* Reset ov5642 for initialization, this function is supposed to be called
 * only at beginning, call to this function will result in value lost in
 * ALL registers */
static int ov5642_int_reset(struct i2c_client *c)
{
	int ret;
	unsigned char val;
	printk("cam: will reset ov5642\n");
	/* S/W reset */
	ret = ov5642_read(c, REG_SYSCTRL, &val);
	if (unlikely(ret))
		return ret;
	ret = ov5642_write(c, REG_SYSCTRL, val|SW_RESET);
	if (unlikely(ret)) {
		printk(KERN_ERR "cam: sensor ov5642 S/W reset failed\n");
		return ret;
	}
	/* Wait till reset complete */
	msleep(2);
	ret = ov5642_write(c, REG_SYSCTRL, val);

	/* Initialize settings*/
	ret |= ov5642_write_array(c, ov5642_fmt_default);
	ret |= ov5642_write_array(c, ov5642_fmt_yuv422);
	ret |= ov5642_write_array(c, ov5642_mipi);
	ret |= ov5642_write_array(c, ov5642_res_qvga);
	if (unlikely(ret)) {
                printk(KERN_ERR "cam: one or more error during ov5642 initialize\n");
                return ret;
        }
	return 0;
}

static int ov5642_g_register(struct i2c_client *client, struct v4l2_dbg_register * reg)
{
	return ov5642_read(client, (u16)reg->reg, (unsigned char *)&(reg->val));
}

static int ov5642_s_register(struct i2c_client *client, struct v4l2_dbg_register * reg)
{
	return ov5642_write(client, (u16)reg->reg, (unsigned char)reg->val);
}

static int ov5642_detect(struct i2c_client *client)
{
	unsigned char v = 0;
	int ret = 0;

	/*
	 * no MID register found. OK, we know we have an OmniVision chip...but which one?
	 */
	ret = ov5642_read(client, REG_PIDH, &v);

	printk(KERN_NOTICE "ov5642_detect 0x%x\n",v);
	if (ret < 0)
		return ret;
	if (v != 0x56)
		return -ENODEV;

	ret = ov5642_read(client, REG_PIDL, &v);

	printk(KERN_NOTICE "ov5642_detect 0x%x\n",v);
	if (ret < 0)
		return ret;
	if (v != 0x42)
		return -ENODEV;

	return 0;
}


/*
 * Store information about the video data format.  The color matrix
 * is deeply tied into the format, so keep the relevant values here.
 * The magic matrix nubmers come from OmniVision.
 */
static struct ov5642_format_struct {
	__u8 *desc;
	__u32 pixelformat;
	struct regval_list *regs;
	int bpp;   /* bits per pixel */
} ov5642_formats[] = {
	{
		.desc		= "YUYV422 planar",
		.pixelformat	= V4L2_PIX_FMT_YUV422P,
		.regs 		= ov5642_fmt_yuv422,
		.bpp		= 16,
	},
	{
		.desc           = "YUYV 4:2:0",
		.pixelformat    = V4L2_PIX_FMT_YUV420,
		.regs           = ov5642_fmt_yuv422,
		.bpp            = 12,
	},
	{
		.desc           = "JFIF JPEG",
		.pixelformat    = V4L2_PIX_FMT_JPEG,
		.regs           = ov5642_fmt_jpg,
		.bpp            = 16,
	},
	{
		.desc           = "YUYV422 packet",
		.pixelformat    = V4L2_PIX_FMT_UYVY,
		.regs           = ov5642_fmt_yuv422,
		.bpp            = 16,
	},
};
#define N_OV5642_FMTS ARRAY_SIZE(ov5642_formats)


/*
 * Then there is the issue of window sizes.  Try to capture the info here.
 */
static struct ov5642_win_size {
	int	width;
	int	height;
	struct regval_list *regs;
} ov5642_win_sizes[] = {
	/* QCIF */
        {
                .width          = 176,
                .height         = 144,
                .regs           = ov5642_res_qcif,
        },
	/* CIF */
        {
		.width          = 352,
		.height         = 288,
		.regs           = ov5642_res_cif,
	},
	/* QVGA */
	{
		.width		= 320,
		.height		= 240,
		.regs           = ov5642_res_qvga,
	},
	/* VGA */
	{
		.width		= 640,
		.height		= 480,
		.regs           = ov5642_res_vga,
	},
	/* WVGA */
	{
		.width		= 800,
		.height 	= 480,
		.regs		= ov5642_res_wvga,
	},
	{
		.width		= 1280,
		.height		= 720,
		.regs		= ov5642_res_720P,
	},
};

static struct ov5642_win_size ov5642_win_sizes_jpeg[] = {
	/* QVGA */
	{
		.width		= 320,
		.height		= 240,
		.regs           = ov5642_res_qvga,
	},
	/* VGA */
	{
		.width		= 640,
		.height		= 480,
		.regs           = ov5642_res_vga,
	},
	/*5M 2592x1944*/
	{
		.width		= 2592,
		.height 	= 1944,
		.regs			= ov5642_res_5M,
	},
};

#define N_WIN_SIZES (ARRAY_SIZE(ov5642_win_sizes))
#define JPEG_SIZE 1024*1024*3/2


static int ov5642_querycap(struct i2c_client *c, struct v4l2_capability *argp)
{
	if (unlikely(argp == NULL)) {
		printk(KERN_ERR"cam: argp is NULL in %s line%d \n", __FUNCTION__, __LINE__);
		return -EINVAL;
	}

	strcpy(argp->driver, "ov5642");
	return 0;
}

static int ov5642_enum_fmsize(struct i2c_client *c, struct v4l2_frmsizeenum *argp)
{
	struct v4l2_frmsizeenum frmsize;
	int ret = 0;

	if (copy_from_user(&frmsize, argp, sizeof(frmsize)))
		   return -EFAULT;

	if (	(frmsize.pixel_format == V4L2_PIX_FMT_YUV422P)
	     ||	(frmsize.pixel_format == V4L2_PIX_FMT_YUV420)
	     ||	(frmsize.pixel_format == V4L2_PIX_FMT_UYVY) ) {
		if (frmsize.index >= N_WIN_SIZES){
			return -EINVAL;
		}
		frmsize.type = V4L2_FRMSIZE_TYPE_DISCRETE;
		frmsize.discrete.height = ov5642_win_sizes[frmsize.index].height;
		frmsize.discrete.width = ov5642_win_sizes[frmsize.index].width;
		goto exit;
	}
	if(frmsize.pixel_format == V4L2_PIX_FMT_JPEG){
		if (frmsize.index >= ARRAY_SIZE(ov5642_win_sizes_jpeg)){
			return -EINVAL;
		}
		frmsize.type = V4L2_FRMSIZE_TYPE_DISCRETE;
		frmsize.discrete.height = ov5642_win_sizes_jpeg[frmsize.index].height;
		frmsize.discrete.width = ov5642_win_sizes_jpeg[frmsize.index].width;
		goto exit;
	}
	ret = -EINVAL;
exit:
	if (copy_to_user(argp, &frmsize, sizeof(frmsize)))
		return -EFAULT;
	return ret;
}

static int ov5642_q_awb(struct i2c_client *client, __s32 *value)
{
	int ret;
	unsigned char v = 0;

	ret = ov5642_read(client, REG_AWB_EN, &v);
	*value = ((v & AWB_DIS) != AWB_DIS);
	return ret;
}

static int ov5642_t_awb(struct i2c_client *client, int value)
{
	unsigned char v = 0;
	int ret;

	ret = ov5642_read(client, REG_AWB_EN, &v);
	if (!value)
		v = AWB_DIS;
	else
		v = 0x00;
	ret = ov5642_write(client, REG_AWB_EN, v);
	return ret;
}

static int ov5642_q_ae(struct i2c_client *client, __s32 *value)
{
	int ret;
	unsigned char v = 0;

	ret = ov5642_read(client, REG_AE_EN, &v);
	*value = ((v & AE_EN) == AE_EN);
	return ret;
}

static int ov5642_t_ae(struct i2c_client *client, int value)
{
	unsigned char v = 0;
	int ret;

	ret = ov5642_read(client, REG_AE_EN, &v);
	if (value)
		v |= AE_EN;
	else
		v &= ~AE_EN;
	ret += ov5642_write(client, REG_AE_EN, v);
	return ret;
}

static int ov5642_q_af(struct i2c_client *client, __s32 *value)
{
	int ret;
	unsigned char v = 0;

	ret = ov5642_read(client, REG_AF_EN, &v);
	*value = (v & AF_EN) == AF_EN;
	return ret;
}

static int ov5642_t_af(struct i2c_client *client, int value)
{
	unsigned char v = 0;
	int ret;

	ret = ov5642_read(client, REG_AF_EN, &v);
	if (value)
		v |= AF_EN;
	else
		v &= ~AF_EN;
	ret += ov5642_write(client, REG_AF_EN, v);
	return ret;
}

/* Flash related functions */
static int ov5642_q_flash_time(struct i2c_client *client, __s32 *time);
static int ov5642_t_flash_time(struct i2c_client *client, int time);
static int ov5642_q_flash_mode(struct i2c_client *client, __s32 *mode);
static int ov5642_t_flash_mode(struct i2c_client *client, int mode);
static int ov5642_q_flash_lum(struct i2c_client *client, __s32 *lum);
static int ov5642_t_flash_lum(struct i2c_client *client, int lum);

static int ov5642_q_flash_time(struct i2c_client *client, __s32 *time)
{
	struct ov5642_info *info = i2c_get_clientdata(client);
	*time = info->flash.duration;
	return *time;
}

static int ov5642_t_flash_time(struct i2c_client *client, int time)
{
	int ret = 0;
	struct ov5642_info *info = i2c_get_clientdata(client);
	if (time < 0) {
		printk(KERN_NOTICE "cam: Invalid flash duration: %d\n", time);
		return -EINVAL;
	}
	info->flash.duration = time;
	if (time == 0)
		info->flash.mode = FLASH_ARG_MODE_EVER;
	else
		info->flash.mode = FLASH_ARG_MODE_TIMED;
	/* If the flash is on, the duration change will affect the
	 * behavoir of flash immediatelly */
	if (info->flash.brightness != FLASH_ARG_LUMI_OFF)
		ret = ov5642_t_flash_lum(client, info->flash.brightness);
	return ret;
}

static int ov5642_q_flash_mode(struct i2c_client *client, __s32 *mode)
{
	struct ov5642_info *info = i2c_get_clientdata(client);
	*mode = info->flash.mode;
	return *mode;
}

static int ov5642_t_flash_mode(struct i2c_client *client, int mode)
{
	struct ov5642_info *info = i2c_get_clientdata(client);

	if (mode >= FLASH_ARG_MODE_MAX)
		return -EINVAL;
	info->flash.mode = mode;
	return 0;
}

static int ov5642_q_flash_lum(struct i2c_client *client, __s32 *lum)
{
	struct ov5642_info *info = i2c_get_clientdata(client);
	*lum = info->flash.brightness;
	return *lum;
}

static int ov5642_t_flash_lum(struct i2c_client *client, int lum)
{
	struct ov5642_info *info = i2c_get_clientdata(client);
	int ret = 0;

	if ((lum < 0) || (lum > FLASH_ARG_LUMI_MAX))
		return -EINVAL;

	if (lum == 0) {
		printk(KERN_DEBUG "Turn OFF flash\n");
		info->flash.brightness = FLASH_ARG_LUMI_OFF;
		/* Request turn OFF the flash, so ignore flash mode */
		clrbit(REG_SYS_RESET, 0x08);	// clear reset
		setbit(REG_CLK_ENABLE, 0x08);	// enable clock
		setbit(REG_PAD_OUTPUT, 0x02);	// pad output enable
		setbit(REG_FREX_MODE, 0x02);	// FREX mode
		/* Strobe control */
		ret = ov5642_write(client, REG_STRB_CTRL, 0x03);
		/* Write again to make sure strobe request end is received
		 * after other bits are saved in the reg, use LED3 mode off */
		ret |= ov5642_write(client, REG_STRB_CTRL, 0x03);
		return ret;
	}

	info->flash.brightness = lum;
	clrbit(REG_SYS_RESET, 0x08);	// clear reset
	setbit(REG_CLK_ENABLE, 0x08);	// enable clock
	setbit(REG_PAD_OUTPUT, 0x02);	// pad output enable
	setbit(REG_FREX_MODE, 0x02);	// FREX mode

	switch (info->flash.mode)
	{
		case FLASH_ARG_MODE_TIMED:
			if (info->flash.duration) {
				/* Strobe control */
				ret = ov5642_write(client, REG_STRB_CTRL, 0x03);
				/* Send strobe request */
				ret |= ov5642_write(client, REG_STRB_CTRL, 0x83);
				msleep(info->flash.duration);
				ret |= ov5642_write(client, REG_STRB_CTRL, 0x03);
				info->flash.brightness = FLASH_ARG_LUMI_OFF;
				return ret;
			}
			/* NO break here, if duration is 0, leave it ON */
		case FLASH_ARG_MODE_EVER:
			/* Strobe control */
			ret = ov5642_write(client, REG_STRB_CTRL, 0x03);
			/* Send strobe request */
			ret |= ov5642_write(client, REG_STRB_CTRL, 0x83);
			return ret;
		case FLASH_ARG_MODE_REPEAT:
			/* Strobe control */
			ret = ov5642_write(client, REG_STRB_CTRL, 0x02);
			/* Send strobe request */
			ret |= ov5642_write(client, REG_STRB_CTRL, 0x82);
			return ret;
		case FLASH_ARG_MODE_BLINK:
			/* Use ov5642 xenon flash mode */
			return ret;
	}
	return 0;
}

static struct ov5642_control {
	struct v4l2_queryctrl qc;
	int (*query)(struct i2c_client *c, __s32 *value);
	int (*tweak)(struct i2c_client *c, int value);
} ov5642_controls[] =
{
	{
		.qc = {
			.id = V4L2_CID_FOCUS_AUTO,
			.type = V4L2_CTRL_TYPE_BOOLEAN,
			.name = "auto focus",
			.minimum = 0,
			.maximum = 1,
			.step = 1,
			.default_value = 0,
		},
		.tweak = ov5642_t_af,
		.query = ov5642_q_af,
	},
	{
		.qc = {
			.id = V4L2_CID_AUTO_WHITE_BALANCE,
			.type = V4L2_CTRL_TYPE_BOOLEAN,
			.name = "auto white balance",
			.minimum = 0,
			.maximum = 1,
			.step = 1,
			.default_value = 0,
		},
		.tweak = ov5642_t_awb,
		.query = ov5642_q_awb,
	},
	{
		.qc = {
			.id = V4L2_CID_EXPOSURE_AUTO,
			.type = V4L2_CTRL_TYPE_BOOLEAN,
			.name = "auto exposure",
			.minimum = 0,
			.maximum = 1,
			.step = 1,
			.default_value = 0,
		},
		.tweak = ov5642_t_ae,
		.query = ov5642_q_ae,
	},
	{
		.qc = {
			.id = V4L2_CID_FLASH_DURATION,
			.type = V4L2_CTRL_TYPE_INTEGER,
			.name = "flash duration",
			.minimum = 0,
			.maximum = 60000,
			.step = 1,
			.default_value = 1000,
		},
		.tweak = ov5642_t_flash_time,
		.query = ov5642_q_flash_time,
	},
		{
		.qc = {
			.id = V4L2_CID_FLASH_MODE,
			.type = V4L2_CTRL_TYPE_INTEGER,
			.name = "flash mode",
			.minimum = FLASH_ARG_MODE_0,
			.maximum = FLASH_ARG_MODE_MAX - 1,
			.step = 1,
			.default_value = 0,
		},
		.tweak = ov5642_t_flash_mode,
		.query = ov5642_q_flash_mode,
	},
	{
		.qc = {
			.id = V4L2_CID_FLASH_LUMINANCE,
			.type = V4L2_CTRL_TYPE_INTEGER,
			.name = "flash brightness",
			.minimum = FLASH_ARG_LUMI_OFF,
			.maximum = FLASH_ARG_LUMI_MAX - 1,
			.step = 1,
			.default_value = 0,
		},
		.tweak = ov5642_t_flash_lum,
		.query = ov5642_q_flash_lum,
	},
};
#define N_CONTROLS (ARRAY_SIZE(ov5642_controls))

static int ov5642_enum_fmt(struct i2c_client *c, struct v4l2_fmtdesc *fmt)
{
	struct ov5642_format_struct *ofmt;

	if (fmt->index >= N_OV5642_FMTS)
		return -EINVAL;

	ofmt = ov5642_formats + fmt->index;
	fmt->flags = 0;
	strncpy(fmt->description, ofmt->desc, min(sizeof(fmt->description), strlen(ofmt->desc)+1));
	fmt->description[sizeof(fmt->description)-1] = 0;
	fmt->pixelformat = ofmt->pixelformat;
	return 0;
}

static int ov5642_try_fmt(struct i2c_client *c, struct v4l2_format *fmt,
		struct ov5642_format_struct **ret_fmt,
		struct ov5642_win_size **ret_wsize)
{
	int index, i;
	struct v4l2_pix_format *pix = &fmt->fmt.pix;
	for (index = 0; index < N_OV5642_FMTS; index++)
		if (ov5642_formats[index].pixelformat == pix->pixelformat)
			break;
	if (index >= N_OV5642_FMTS) {
		printk(KERN_ERR "cam: unsupported format!\n");
		return -EINVAL;
	}

	if (ret_fmt != NULL)
		*ret_fmt = &ov5642_formats[index];

	if (pix->pixelformat == V4L2_PIX_FMT_JPEG) {
		for (i = 0; i < ARRAY_SIZE(ov5642_win_sizes_jpeg); i++)
			if (pix->width == ov5642_win_sizes_jpeg[i].width && pix->height == ov5642_win_sizes_jpeg[i].height)
				break;

		if (i >= ARRAY_SIZE(ov5642_win_sizes_jpeg)) {
			printk(KERN_ERR"cam: jpeg resolution(%d, %d) unsupported\n", pix->width, pix->height);
			return -EINVAL;
		}

		pix->bytesperline = 2048;
		/* For jpeg format, leave v4l2_format.v4l2_pix_format.sizeimage untouched, it's managed by userspace */
		if (ret_wsize != NULL)
			*ret_wsize = ov5642_win_sizes_jpeg + i;
	}else{
		for (i = 0; i < N_WIN_SIZES; i++)
			if (pix->width == ov5642_win_sizes[i].width && pix->height == ov5642_win_sizes[i].height)
				break;

		if (i>= N_WIN_SIZES){
			printk(KERN_ERR"cam: YUV resolution(%d, %d) unsupported!\n", pix->width, pix->height);
			return -EINVAL;
		}

		pix->bytesperline = pix->width*ov5642_formats[index].bpp/8;
		pix->sizeimage = pix->height*pix->bytesperline;

		if (ret_wsize != NULL)
			*ret_wsize = ov5642_win_sizes + i;
	}
	return 0;

}


static struct ov5642_control *ov5642_find_control(__u32 id)
{
	int i;

	for (i = 0; i < N_CONTROLS; i++)
		if (ov5642_controls[i].qc.id == id)
			return ov5642_controls + i;
	return NULL;
}

static int ov5642_s_ctrl(struct i2c_client *client, struct v4l2_control *ctrl)
{
	struct ov5642_control *octrl = ov5642_find_control(ctrl->id);
	int ret;

	if (octrl == NULL)
		return -EINVAL;
	ret =  octrl->tweak(client, ctrl->value);
	if (ret >= 0)
		return 0;
	return ret;
}

static int ov5642_q_ctrl(struct i2c_client *client,
		struct v4l2_queryctrl *qc)
{
	struct ov5642_control *ctrl = ov5642_find_control(qc->id);

	if (ctrl == NULL)
		return -EINVAL;
	*qc = ctrl->qc;
	return 0;
}

static int ov5642_g_ctrl(struct i2c_client *client, struct v4l2_control *ctrl)
{
	struct ov5642_control *octrl = ov5642_find_control(ctrl->id);
	int ret;

	if (octrl == NULL)
		return -EINVAL;
	ret = octrl->query(client, &ctrl->value);

	/*printk(KERN_NOTICE "cam: ov5642_g_ctrl %d\n",ctrl->value);*/
	if (ret >= 0)
		return 0;
	return ret;
}


/*
 * Set a format.
 */
static int ov5642_s_fmt(struct i2c_client *c, struct v4l2_format *fmt)
{
	int ret = 0;
	struct ov5642_format_struct *ovfmt = NULL;
	struct ov5642_win_size *wsize = NULL;
	struct v4l2_pix_format *pix = &fmt->fmt.pix;

	ret = ov5642_try_fmt(c, fmt, &ovfmt, &wsize);
	if (ret)
		return ret;

	if(V4L2_PIX_FMT_JPEG == pix->pixelformat) {
		ov5642_write_array(c, ov5642_jpg_no_reset);
		ov5642_write_array(c, wsize->regs);
		printk(KERN_NOTICE"cam: JPEG resolution(%d, %d)\n", \
					wsize->width, wsize->height);
	} else {
		switch (pix->width) {
			/*1920x1080(1080p), a separate sensor setting*/
			case 1920:
				ov5642_write_array(c, ov5642_yuv_1080p);
				break;

			/*1280x720(720p), a separate sensor setting*/
			case 1280:
				ov5642_write_array(c, ov5642_yuv_720p);
				break;

			default:
				{/* A W/R for switch between HD resolution
				  * and others */
				char ch[2];
				int resY;
				ov5642_read(c, 0x380A, ch);
				ov5642_read(c, 0x380B, ch+1);
				resY = (ch[0]<<8) + ch[1];
				if ((resY == 720) || (resY == 1080))
					ov5642_int_reset(c);
				}
				ov5642_write_array(c, ov5642_preview_no_reset);
				ov5642_write_array(c, ovfmt->regs);
				break;
		}
		ov5642_write_array(c, wsize->regs);
		printk(KERN_NOTICE "cam: YUV resolution(%d, %d)\n", \
					wsize->width, wsize->height);
	}

	return ret;
}


/*
 * Implement G/S_PARM.  There is a "high quality" mode we could try
 * to do someday; for now, we just do the frame rate tweak.
 */
static int ov5642_g_parm(struct i2c_client *c, struct v4l2_streamparm *parms)
{
	return 0;
}

static int ov5642_s_parm(struct i2c_client *c, struct v4l2_streamparm *parms)
{
	return 0;
}

static int ov5642_s_input(struct i2c_client *c, int *id)
{
	return 0;
}

extern struct cam_platform_data *init_platform_ops;

int ov5642_sensor_on (struct i2c_client *client)
{
	struct sensor_platform_data *pdata;
	pdata = client->dev.platform_data;
	pdata->power_set(1, SENSOR_OPEN);
	printk(KERN_NOTICE "ov5642_sensor_on\n");
	return 0;
}

int ov5642_sensor_off (struct i2c_client *client)
{
	struct sensor_platform_data *pdata;
	pdata = client->dev.platform_data;
	pdata->power_set(1, SENSOR_CLOSE);
	printk(KERN_NOTICE "ov5642_sensor_off\n");
	return 0;
}

int ov5642_bridge(struct i2c_client *client, struct v4l2_format *fmt)
{
	struct v4l2_pix_format *pix = &fmt->fmt.pix;

	printk(KERN_NOTICE "cam_OV5642_brdige\n");
	ov5642_write_array(client, ov5642_bridge_mode_start);
	if ((pix->width == 176) && (pix->height == 144))
	{
		ov5642_write_array(client, ov5642_bridge_res_qcif);
	}
	else if ((pix->width == 352) && (pix->height == 288))
	{
		ov5642_write_array(client, ov5642_bridge_res_cif);
	}
	else if ((pix->width == 320) && (pix->height == 240))
	{
		ov5642_write_array(client, ov5642_bridge_res_qvga);
	}
	else if ((pix->width == 640) && (pix->height == 480))
	{
		ov5642_write_array(client, ov5642_bridge_res_vga);
	}
	else
	{
		printk(KERN_NOTICE "ov5642_bridge: bridge format is not supported\n");
	}
		ov5642_write_array(client, ov5642_bridge_mode_end);
	msleep(1);
	return 0;
}

/*
 * Basic i2c stuff.
 */
static int __devinit ov5642_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
	int ret,i;
	struct ov5642_info *info;
	struct sensor_platform_data *pdata;
	printk(KERN_NOTICE "cam: ov5642_probe!\n");

	pdata = client->dev.platform_data;
	pdata->power_set(pdata->id, SENSOR_OPEN);
	/*
	 * Set up our info structure.
	 */
	info = kzalloc(sizeof (struct ov5642_info), GFP_KERNEL);
	if (! info) {
		ret = -ENOMEM;
		goto out;
	}
	info->fmt = &ov5642_formats[1];
	info->sat = 128;	/* Review this */
	info->flash.brightness = FLASH_ARG_LUMI_OFF;
	info->flash.duration = FLASH_ARG_TIME_OFF;
	info->flash.mode = FLASH_ARG_MODE_EVER;
	i2c_set_clientdata(client, info);

	/*
	 * Make sure it's an ov5642
	 */
	for (i = MAX_DETECT_NUM; i > 0; --i) {
		ret = ov5642_detect(client);
		if (!ret) {
			printk(KERN_NOTICE "cam: OmniVision ov5642 sensor detected!\n");
			goto label_sensor_detected;
		}
		printk(KERN_ERR "cam: OV5642 detect failure, will retry\n");
	}
	/* NO OV5642 detected within limited loops */
	printk(KERN_NOTICE "cam: Abort retry, failed to detect OmniVision ov5642!\n");
	ret = -ENODEV;
	goto out_free_info;
label_sensor_detected:
	ccic_sensor_attach(client);
	ret = 0;
	goto out;

out_free_info:
	kfree(info);
out:
	pdata->power_set(pdata->id, SENSOR_CLOSE);
	return ret;
}


static int ov5642_remove(struct i2c_client *client)
{
	struct ov5642_info *info;
	struct sensor_platform_data *pdata;

	pdata = client->dev.platform_data;
	pdata->power_set(pdata->id, SENSOR_CLOSE);
	ccic_sensor_detach(client);

	info = i2c_get_clientdata(client);
	i2c_set_clientdata(client, NULL);
	kfree(info);
	return 0;
}

static int ov5642_streamon(struct i2c_client *client)
{
	unsigned char val;
	ov5642_read(client, 0x3008, &val);
	val &= ~0x40;
	ov5642_write(client, 0x3008, val);
	return 0;
}
static int ov5642_streamoff(struct i2c_client *client)
{
	return 0;
}

static int ov5642_command(struct i2c_client *client, unsigned int cmd,
		void *arg)
{
	switch (cmd) {
		case VIDIOC_DBG_G_CHIP_IDENT:
			return v4l2_chip_ident_i2c_client(client, arg, V4L2_IDENT_OV5642, 0);

		case VIDIOC_INT_RESET:
			return ov5642_int_reset(client);
		case VIDIOC_QUERYCAP:
			return ov5642_querycap(client, (struct v4l2_capability *)arg);
		case VIDIOC_ENUM_FMT:
			return ov5642_enum_fmt(client, (struct v4l2_fmtdesc *) arg);
		case VIDIOC_TRY_FMT:
			return ov5642_try_fmt(client, (struct v4l2_format *) arg, NULL, NULL);
		case VIDIOC_S_FMT:
			return ov5642_s_fmt(client, (struct v4l2_format *) arg);
		case VIDIOC_ENUM_FRAMESIZES:
                        return ov5642_enum_fmsize(client, (struct v4l2_frmsizeenum *) arg);
		case VIDIOC_QUERYCTRL:
			return ov5642_q_ctrl(client, (struct v4l2_queryctrl *) arg);
		case VIDIOC_S_CTRL:
			return ov5642_s_ctrl(client, (struct v4l2_control *) arg);
		case VIDIOC_G_CTRL:
			return ov5642_g_ctrl(client, (struct v4l2_control *) arg);
		case VIDIOC_S_PARM:
			return ov5642_s_parm(client, (struct v4l2_streamparm *) arg);
		case VIDIOC_G_PARM:
			return ov5642_g_parm(client, (struct v4l2_streamparm *) arg);
		case VIDIOC_S_INPUT:
			return ov5642_s_input(client, (int *) arg);
		case VIDIOC_STREAMON:
			return ov5642_streamon(client);
		case VIDIOC_STREAMOFF:
			return ov5642_streamoff(client);
		case VIDIOC_SET_BRIDGE:
			ov5642_sensor_on(client);
			msleep(1);
			return	ov5642_bridge(client, arg);
		case VIDIOC_DBG_G_REGISTER:
			return ov5642_g_register(client, (struct v4l2_dbg_register *) arg);
		case VIDIOC_DBG_S_REGISTER:
			return ov5642_s_register(client, (struct v4l2_dbg_register *) arg);
	}
	return -EINVAL;
}

static struct i2c_device_id ov5642_idtable[] = {
	{ "ov5642", 0 },
	{ }
};

MODULE_DEVICE_TABLE(i2c, ov5642_idtable);

static struct i2c_driver ov5642_driver = {
	.driver = {
		.name	= "ov5642",
	},
	.id_table       = ov5642_idtable,
	.command	= ov5642_command,
	.probe		= ov5642_probe,
	.remove		= ov5642_remove,
};


/*
 * Module initialization
 */
static int __init ov5642_mod_init(void)
{
	int ret = 0;
	ret = i2c_add_driver(&ov5642_driver);
	printk(KERN_NOTICE "cam: try to init OmniVision ov5642 sensor driver!\n");

	return ret;

}

static void __exit ov5642_mod_exit(void)
{
	i2c_del_driver(&ov5642_driver);
}

late_initcall(ov5642_mod_init);
module_exit(ov5642_mod_exit);

