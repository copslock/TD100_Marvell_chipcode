/***************************************************************************************** 
Copyright (c) 2009, Marvell International Ltd. 
All Rights Reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Marvell nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY MARVELL ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL MARVELL BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*****************************************************************************************/

/************
Header files
*************/


/* Standard IPP headers */
//#include	"ippdefs.h"
//#include	"ippAC.h"

/* Definitions and prototypes for high-level*/
#include "codecAC.h"
#include "misc.h"

#include "ippLV.h"

/****************
 True and false 
 constant
****************/ 
#define	FALSE			0		
#define	TRUE			1	

#ifndef AV_FORMAT
#define FILE_IO
#endif

#define IPP_MP3_SFB_TABLE_LONG_LEN	138 
#define IPP_MP3_SFB_TABLE_SHORT_LEN	84
#define IPP_MP3_MBP_TABLE_LEN 12
#define MAX_PAR_NAME_LEN    1024
#define MAX_PAR_VALUE_LEN   2048

typedef const Ipp16s IppMP3ScaleFactorBandTableLong[IPP_MP3_SFB_TABLE_LONG_LEN]; /* 138 elements */
typedef const Ipp16s IppMP3ScaleFactorBandTableShort[IPP_MP3_SFB_TABLE_SHORT_LEN]; /* 84 elements */
typedef const Ipp16s IppMP3MixedBlockPartitionTable[IPP_MP3_MBP_TABLE_LEN];


/*************
 Prototypes 
**************/
void DisplayConsoleStartupBanner(void);
int  ShiftAndFillStreamBuf(IPP_FILE *fp, IppBitstream *pBitStream);
void DisplayLibVersion();

/******************************************************************************
// Name:			 DisplayLibVersion
//
// Description:		 Display library build information on the text console
//
// Input Arguments:  None.
//
// Output Arguments: None				
//
// Returns:			 None				
*******************************************************************************/
void DisplayLibVersion()
{
	char libversion[128]={'\0'};
	IppCodecStatus ret;
	ret = GetLibVersion_MP3DEC(libversion,sizeof(libversion));
	if(0 == ret){
		IPP_Printf("\n*****************************************************************\n");
	    IPP_Printf("This library is built from %s\n",libversion);
		IPP_Printf("*****************************************************************\n");
	}else{
		IPP_Printf("\n*****************************************************************\n");
		IPP_Printf("Can't find this library version information\n");
		IPP_Printf("*****************************************************************\n");
	}
}

/*************************************
 Console-mode application entry point 
**************************************/
/******************************************************************************
// Name:			 main
//
// Description:		 MP3 player sample code
//					 Demonstrates the Intel Integrated Performance Primitives 
//					 (IPP) MP3 API Compatible with streams generated by the 
//					 following encoder types:
//						1) ISO/IEC 11172-3, "MPEG-1" audio, Layer 3
//						2) IS 13818-3, "MPEG-2" audio, Layer 3, LSF extensions 
//						   1, 2-channel modes only
//						3) MPEG2.5
//					Usage:   mp3dec <input file> [<output file>] [--help], 
//
//					where
//							<input file> is the name of a valid .mp3 file
//							<output file> (optional) is the desired binary pcm 
//							output file	--help displays usage
//
//							No output file is generated unless a file name is 
//							specified
//
// Input Arguments:  argc			- Standard C argument count
//					 argv			- Standard C argument list
//
// Output Arguments: None			- Pointer to the PCM audio output buffer
//
// Returns:			 None.
//
******************************************************************************/
int MP3Dec(char* pSrcFileName, char* pDstFileName, char* pLogFileName)
{
	IppBitstream bitStream;			/* MP3 bit stream */
	IppSound sound;					/* Output sound structure */
	void  *pDecoderState = NULL;	/* MP3 decoder state */
	int bufSize;					/* Buffer size variable */
	IPP_FILE *fpi;
	IPP_FILE *fpo;					/* Input and output file pointers */
	int firstRun=0;
    int frameNum=0;		/* Frame counter */
	int done;						/* Main loop boolean status */			
	int iResult;
	int lastEnd;
	int offset = 0;
	int s, c, temp;
	int perf_index;
	long long TotTime;
	Ipp8u *pOutputBuf;  /* buffer for output */
	Ipp8u *pInputBuf;	/* buffer for input */	
	MiscGeneralCallbackTable   *pCallBackTable = NULL;
	iResult = IPP_STATUS_INIT_ERR;
	bufSize =0;

	if ( miscInitGeneralCallbackTable(&pCallBackTable) != 0 ) {
		return IPP_FAIL; 
	}

	DisplayConsoleStartupBanner();
	DisplayLibVersion();
	
	fpi = IPP_Fopen(pSrcFileName, "rb");
	if(fpi == NULL){
		IPP_Log(pLogFileName,"a","can not open input file\n");
		return IPP_FAIL;
	}
		
	fpo = IPP_Fopen(pDstFileName, "wb");
	if(fpo == NULL){
		IPP_Log(pLogFileName,"a","can not open output file\n");
	}

	IPP_MemMalloc(&pInputBuf, INPUT_BUF_SIZE_MP3, 4);
	bitStream.pBsBuffer = pInputBuf;
	bitStream.pBsCurByte = bitStream.pBsBuffer;
	bitStream.bsCurBitOffset = 0;

	while(iResult != IPP_STATUS_NOERR) {
		if((bitStream.bsByteLen = IPP_Fread(bitStream.pBsBuffer, 1, INPUT_BUF_SIZE_MP3,fpi)) < INPUT_BUF_SIZE_MP3) {
			IPP_Log(pLogFileName,"a","Error Message: The input bitstream comes to end!\nInitialization failed!\n");
			IPP_MemFree(&(bitStream.pBsBuffer));
			if(fpi != NULL) 	IPP_Fclose(fpi);
			if(fpo != NULL) 	IPP_Fclose(fpo);
			return IPP_FAIL;
		}
		bitStream.pBsCurByte = bitStream.pBsBuffer;
		iResult = DecodeSendCmd_MP3Audio(IPPAC_MP3_FINDNEXT_SYNCWORD,&bitStream, &offset, NULL);
	}
	iResult = DecoderInitAlloc_MP3(&bitStream, pCallBackTable, &sound,&pDecoderState);
	if(iResult != IPP_STATUS_INIT_OK)
		return IPP_FAIL;
	

	/* malloc space for output structure -- sound */
	IPP_MemMalloc(&pOutputBuf, OUTPUT_BUF_SIZE_MP3+4, 4);
	sound.pSndFrame = (Ipp16s*)pOutputBuf;
	/**************************************************************************
	Invoke frame decoder until input file empty

	The following frame decoder outcomes are possible:

		1. IPP_STATUS_FRAME_COMPLETE
									- Sufficient data was present in the 
									  bitstream buffer to decode 1 frame, no 
									  frame abnormalities were detected. Upon 
									  return, PCM samples are present in the PCM
									  output buffer.

		2. IPP_STATUS_BUFFER_UNDERRUN
									- Insufficient data present in the bitstream 
									  buffer to decode 1 frame; application 
									  loads additional stream bytes into the 
									  ring buffer and invokes the decoder once 
									  again. 
                                 
		3. IPP_STATUS_FRAME_UNDERRUN
									- Insufficient main_data was buffered during 
									  previous frames to decode successfully the 
									  current frame.  This typically happens, 
									  for example, when decoding a randomly 
									  truncated stream from some arbitrary 
									  midpoint.

		4. IPP_STATUS_FRAME_HEADER_INVALID
									- Invalid frame header found adjacent to a 
									  valid syncword; the application calls 
									  decoder again to find next sync word.

		5. IPP_STATUS_SYNCNOTFOUND_ERR
									- No sync word found in the ring buffer; 
									  typically signifies end of stream

		6. IPP_STATUS_FRAME_ERR		- Some error occurs in the decoding.
		
		7. IPP_STATUS_NOTSUPPORTED_ERR
									- Not support bit stream format.
								
	**************************************************************************/
	done = FALSE;
	lastEnd = FALSE;

	/* initialize for performance data collection */
	IPP_GetPerfCounter(&perf_index,DEFAULT_TIMINGFUNC_START, DEFAULT_TIMINGFUNC_STOP);
	IPP_ResetPerfCounter(perf_index);

	while (!done)
	{

		/*********************************************************************
		 IPP MP3 high-level decoder function: Decode the next frame in the raw 
		 mp3 stream ring buffer 
		**********************************************************************/
		IPP_StartPerfCounter(perf_index);
		iResult = Decode_MP3(&bitStream, &sound,pDecoderState);
		IPP_StopPerfCounter(perf_index);

		switch( iResult ) {
			case IPP_STATUS_FRAME_COMPLETE:
				{
				void * pIn =NULL;
				++frameNum;
				/* The audio can be output to a wave device or a file,
				in this code, it is written to a file */
				
				if(fpo != NULL) IPP_Fwrite(sound.pSndFrame, 1,sound.sndLen, fpo);

				if(firstRun ==0){
					DecodeSendCmd_MP3Audio(IPPAC_MP3_GET_SAMPLERATE,pIn, &s,pDecoderState);
					IPP_Log(pLogFileName,"a","Sample Rate = %dHz\n",s);
					DecodeSendCmd_MP3Audio(IPPAC_MP3_GET_BITRATE,pIn, &temp,pDecoderState);
					IPP_Log(pLogFileName,"a","Bit Rate Index= %d\n",temp);
					DecodeSendCmd_MP3Audio(IPPAC_MP3_GET_CHANNEL,pIn, &c,pDecoderState);
					IPP_Log(pLogFileName,"a","Channel = %d\n",c);
					DecodeSendCmd_MP3Audio(IPPAC_MP3_GET_LAYER,pIn, &temp,pDecoderState);
					IPP_Log(pLogFileName,"a","Layer = %d\n",temp);
					if(IPP_STATUS_NOTSUPPORTED_ERR !=DecodeSendCmd_MP3Audio(IPPAC_MP3_GET_VERSION,pIn, &temp,pDecoderState)){
						IPP_Log(pLogFileName,"a","Version = %d\n",temp);
					}
					audio_open(s,c);
					firstRun++;
				}
				audio_render(sound.pSndFrame, sound.sndLen, c);
				break;
				}
			case IPP_STATUS_FRAME_UNDERRUN:
				break;
			case IPP_STATUS_FRAME_HEADER_INVALID:
			case IPP_STATUS_FRAME_ERR:
				/* Skip this frame or other process here */
				break;
			case IPP_STATUS_NOTSUPPORTED_ERR:
				IPP_Log(pLogFileName,"a","Error: This stream is not supported\n");
//				done = TRUE;
				break;
			case IPP_STATUS_BUFFER_UNDERRUN:
			case IPP_STATUS_SYNCNOTFOUND_ERR:
				if(lastEnd) {
					done = TRUE;
					break;
				}
				iResult = ShiftAndFillStreamBuf(fpi,&bitStream);
				if ( iResult ) {
					lastEnd = TRUE;
				}

				break;
			default:
				done = TRUE;
				break;
		}
	}

	audio_close();

	/* log codec performance and exit performance counting */
	TotTime = IPP_GetPerfData(perf_index);
	
	IPP_FreePerfCounter(perf_index);

	g_Frame_Num[IPP_AUDIO_INDEX] = frameNum;
	g_Tot_Time[IPP_AUDIO_INDEX] = TotTime;
	/* Close I/O devices */	
	IPP_Log(pLogFileName,"a","\nBegin to close files!\n");
	IPP_Log(pLogFileName,"a","End frame number is %d\n", frameNum);
	if(fpi != NULL) 	IPP_Fclose(fpi);
	if(fpo != NULL) 	IPP_Fclose(fpo);
	

	/* Release the buffers */
	IPP_MemFree(&pInputBuf);
	IPP_MemFree(&pOutputBuf);
	DecoderFree_MP3(&pDecoderState);
	miscFreeGeneralCallbackTable(&pCallBackTable);

	return IPP_OK;
} /* End of main() */

/******************************************************************************
// Name:			 ShiftAndFillStreamBuf
//
// Description:		 Bitstream buffer manager.
//					 Loads mp3 stream bytes into the bitstream buffer required 
//					 by the IPP MP3 API.  Maitains the buffer pointers.
//
// Input Arguments:  fp				- MP3 input stream pointer
//					 pBitStream		- Bitstream ring buffer structure pointer
//
// Output Arguments: None				
//
// Returns:			 None
//
******************************************************************************/
int ShiftAndFillStreamBuf(IPP_FILE *fp, IppBitstream *pBitStream)
{

	int i,shiftLength,fillLength;
	int readByte;
	int val;
	Ipp8u *pFillPos,*pShiftPos;

	shiftLength = 4096;
	shiftLength = shiftLength - (pBitStream->pBsCurByte - pBitStream->pBsBuffer);
	pShiftPos = pBitStream->pBsCurByte;

	for(i=0;i<shiftLength;i++) {
		pBitStream->pBsBuffer[i] = pBitStream->pBsCurByte[i];
	}

	pFillPos = &(pBitStream->pBsBuffer[shiftLength]);
	pBitStream->pBsCurByte = pFillPos;

	fillLength = 4096 - shiftLength;
	readByte = IPP_Fread(pFillPos, 1, fillLength, fp);

	if(readByte < fillLength) {		/* End of file */
		if(readByte == 0) {		/* Last frame is the end frame */
			val = 2;
		} else {
			val = 1;
		}
	} else {
		val = 0;
	}

	pBitStream->bsByteLen = readByte + (pBitStream->pBsCurByte - pBitStream->pBsBuffer);
	pBitStream->pBsCurByte = pBitStream->pBsBuffer;

	return val;

} /* End of ShiftAndFillStreamBuf() */

/********************************
 Console management and file I/O 
*********************************/
/*********************************************************************************************
// Name:			 DisplayConsoleStartupBanner
//
// Description:		 Display startup message on the text console
//
// Input Arguments:  None.
//
// Output Arguments: None				
//
// Returns:			 None				
**********************************************************************************************/
void DisplayConsoleStartupBanner()
{
	int i;
	for(i=0;i<2;i++) IPP_Printf("\n");
	IPP_Printf("MP3 Decoder Demonstration, Version 1.0\n");
	IPP_Printf("ISO/IEC 11172-3 MPEG-1 Layer III\nISO IS13818-3 MPEG-2 LSF Layer III\n");
	IPP_Printf("MP3 Extention Format\n\n");
}



/******************************************************************************
// Name:                ParseCmdTemplate
// Description:         Parse the user command 
//
// Input Arguments:
//      pCmdLine    :   Pointer to the input command line
//
// Output Arguments:
//      pSrcFileName:   Pointer to src file name
//      pDstFileName:   Pointer to dst file name
//      pLogFileName:   Pointer to log file name
//      pParSet     :   Pointer to codec parameter set
// Returns:
//        [Success]     IPP_OK
//        [Failure]     IPP_FAIL
******************************************************************************/
int ParseMP3DecCmd(char *pCmdLine, 
                     char *pSrcFileName, 
                     char *pDstFileName, 
                     char *pLogFileName)
{
    char *pCur, *pEnd;
    char par_name[MAX_PAR_NAME_LEN];
    int  par_name_len;
    int  par_value_len;
    char *p1, *p2, *p3;

    pCur = pCmdLine;
    pEnd = pCmdLine + IPP_Strlen(pCmdLine);

    while((p1 = IPP_Strstr(pCur, "-"))){
        p2 = IPP_Strstr(p1, ":");
        if (NULL == p2) {
            return IPP_FAIL;
        }
        p3 = IPP_Strstr(p2, " "); /*one space*/
        if (NULL == p3) {
            p3 = pEnd;
        }

        par_name_len    = p2 - p1 - 1;
        par_value_len   = p3 - p2 - 1;

        if ((0 >= par_name_len)  || (MAX_PAR_NAME_LEN <= par_name_len) ||
            (0 >= par_value_len) || (MAX_PAR_VALUE_LEN <= par_value_len)) {
                return IPP_FAIL;
        }

        IPP_Strncpy(par_name, p1 + 1, par_name_len);
		 par_name[par_name_len] = '\0';
        if ((0 == IPP_Strcmp(par_name, "i")) || (0 == IPP_Strcmp(par_name, "I"))) {
            /*input file*/
            IPP_Strncpy(pSrcFileName, p2 + 1, par_value_len);
			  pSrcFileName[par_value_len] = '\0';
        } else if ((0 == IPP_Strcmp(par_name, "o")) || (0 == IPP_Strcmp(par_name, "O"))) {
            /*output file*/
            IPP_Strncpy(pDstFileName, p2 + 1, par_value_len);
			 pDstFileName[par_value_len] = '\0';
        } else if ((0 == IPP_Strcmp(par_name, "l")) || (0 == IPP_Strcmp(par_name, "L"))) {
            /*log file*/
            IPP_Strncpy(pLogFileName, p2 + 1, par_value_len);
			  pLogFileName[par_value_len] = '\0';
        } else if ((0 == IPP_Strcmp(par_name, "p")) || (0 == IPP_Strcmp(par_name, "P"))) {
            /*par file*/
            /*parse par file to fill pParSet*/
		} 

        pCur = p3;
    }

    return IPP_OK;
}

/******************************************************************************
// Name:                CodecTest
// Description:         Main entry for AAC decoder test
//
// Input Arguments:
//                      N/A
// Output Arguments:
//                      N/A
// Returns:
******************************************************************************/
int CodecTest(int argc, char** argv)
{
    char pSrcFileName[256];
    char pDstFileName[256];
    char pLogFileName[256];
	
	IPP_Memset(pSrcFileName, 0x0, 256);
	IPP_Memset(pDstFileName, 0x0, 256);
	IPP_Memset(pLogFileName, 0x0, 256);
   
    if(argc == 2 && ParseMP3DecCmd(argv[1], pSrcFileName, pDstFileName, pLogFileName) == 0){
           return (MP3Dec(pSrcFileName, pDstFileName,pLogFileName));
    }else{
        IPP_Printf("Command is incorrect! \n \
		Usage:appMP3Dec.exe \"-i:test.mp3 -o:test.pcm -l:test.log \"\n\
		-i input file \n \
		-o output file \n \
		-l log file \n  "); 
		return IPP_FAIL;
	}
    
}