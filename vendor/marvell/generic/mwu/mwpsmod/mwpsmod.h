/*
 * Copyright (C) 2011 Marvell International Ltd., All Rights Reserved
 *
 * MARVELL CONFIDENTIAL
 * The source code contained or described herein and all documents related to
 * the source code ("Material") are owned by Marvell International Ltd or its
 * suppliers or licensors. Title to the Material remains with Marvell International Ltd
 * or its suppliers and licensors. The Material contains trade secrets and
 * proprietary and confidential information of Marvell or its suppliers and
 * licensors. The Material is protected by worldwide copyright and trade secret
 * laws and treaty provisions. No part of the Material may be used, copied,
 * reproduced, modified, published, uploaded, posted, transmitted, distributed,
 * or disclosed in any way without Marvell's prior express written permission.
 *
 * No license under any patent, copyright, trade secret or other intellectual
 * property right is granted to or conferred upon you by disclosure or delivery
 * of the Materials, either expressly, by implication, inducement, estoppel or
 * otherwise. Any license under such intellectual property rights must be
 * express and approved by Marvell in writing.
 *
 */

/* Internal interface for "mwpsmod" module
 *
 * OVERVIEW
 *
 * A typical wps use case involves two nodes: a registrar and an enrollee.  The
 * enrollee initiates a wps session with the registrar to learn the credentials
 * necessary to connect to a network managed by the registrar.  A "device
 * password" or PIN that is a property of the enrollee is used as the shared
 * secret for authentication and encryption during the wps protocol.  In order
 * for wps to proceed, the registrar must know the enrollee's pin, and the
 * enrollee must initiate the session.  If the enrollee initiates the session
 * before the registrar knows the pin, a suitable event will be generated on
 * the enrollee and the registrar to accomodate user interaction.
 *
 * For the purposes of illustrating the details involved in the WPS
 * transaction, imagine that two nodes are both running an instance of this wps
 * module.
 *
 * Our story begins when both the registrar and enrollee have launched mwpsmod
 * by calling mwpsmod_launch().  Next, the registrar must call
 * mwpsmod_registrar_init() with a struct module which specifies the interface
 * on which the registrar is to be run, the device information to be advertised
 * (e.g, model name), and the credential information that is to be shared.
 * Next, mwpsmod_registrar_start() must be called to actually start the
 * registrar.  The registrar is now up and running.  Optionally,
 * mwpsmod_registrar_set_pin() can be called with the pin of the expected
 * enrollee.  If there is no expected enrollee, there is no need to call
 * mwpsmod_registrar_set_pin().  On the enrollee side, mwpsmod_enrollee_init()
 * must be called with a struct module and suitable device information.
 *
 * After this, the enrollee must discover the mac address of the registrar.
 * This can be achieved via scan results from a different program, or perhaps
 * via wifi direct peer discovery and group negotiation.  Next, the enrollee
 * initiates the WPS session with a call to mwpsmod_enrollee_start().  At this
 * time, the pin must be provided.  A suitable pin can be generated by calling
 * mwpsmod_random_pin().  If PBC is to be used, the pin should be the empty
 * string.  If the registrar knows the pin for the enrollee, WPS will proceed.
 * When it completes, the enrollee will get a MWPSMOD_EVENT_ENROLLEE_DONE
 * event.  This event will indicate whether or not the operation succeeded.
 * After this event, the enrollee will be back in its initial state such that
 * mwpsmod_enrollee_start() can be called again.  On the other side, the
 * registrar will get a MWPSMOD_EVENT_REGISTRAR_DONE event.  This event will
 * indicate whether or not an enrollee with that pin was successfully enrolled
 * or not.
 *
 * Suppose the registrar does not know the pin of the enrollee when the
 * enrollee initiates a session.  In this case, the enrollee will get
 * MWPSMOD_EVENT_ENROLLEE_DONE with a status of MWPSMOD_ERR_NOTREADY and some
 * information about the registrar.  It is expected that in response to this
 * event the enrollee will prompt its user to enter pin information (or push
 * the button) on the registrar.  After this user interaction,
 * mwpsmod_enrollee_start() can be called again to re-initiate the session.  On
 * the registrar side, MWPSMOD_EVENT_REGISTRAR_DONE will be emitted with a
 * status of MWPSMOD_ERR_NOTREADY so that similar user interaction can take
 * place.  Presumably, this user interaction will result in
 * mwpsmod_registrar_set_pin() being called.
 *
 * If the enrollee decides he wants to cancel enrolling after calling
 * mwpsmod_enrollee_start() but before getting the MWPSMOD_EVENT_ENROLLEE_DONE,
 * he can call mwpsmod_enrollee_stop().  Similarly, whenever the registrar
 * wishes to stop, he should call mwpsmod_registrar_stop().
 */

#ifndef __MWPSMOD_INTERNAL__
#define __MWPSMOD_INTERNAL__

#include "module.h"
#include "wps_def.h"

/* enum mwpsmod_error
 *
 * These are the return codes that can be returned by the mwpsmod module
 *
 * MWPSMOD_ERR_SUCCESS: The operation succeeded.
 * MWPSMOD_ERR_BUSY: The module is busy and cannot handle the operation.
 * MWPSMOD_ERR_INVAL: The arguments were invalid.
 * MWPSMOD_ERR_NOMEM: Insufficient available memory.
 * MWPSMOD_ERR_COM: A system-dependent communication failure has occurred (e.g.,
 * permission denied, failed to create socket, etc.)
 * MWPSMOD_ERR_UNSUPPORTED: The operation is not supported.
 * MWPSMOD_ERR_NOENT: No such entity.
 * MWPSMOD_ERR_TIMEOUT: the operation timed out
 * MWPSMOD_ERR_NOTREADY: the module is not ready to perform the operation
 */
enum mwpsmod_error {
    MWPSMOD_ERR_SUCCESS = 0,
    MWPSMOD_ERR_BUSY,
    MWPSMOD_ERR_INVAL,
    MWPSMOD_ERR_NOMEM,
    MWPSMOD_ERR_COM,
    MWPSMOD_ERR_UNSUPPORTED,
    MWPSMOD_ERR_NOENT,
    MWPSMOD_ERR_TIMEOUT,
    MWPSMOD_ERR_NOTREADY,
    MWPSMOD_ERR_NAK,
};

/* NOTE: These constants are defined elsewhere.  However, the header files in
 * which they are defined require a whole litany of other files to be included
 * first, and this is causing occasional build problems.  So we redefine them
 * here.  If some day these constants are defined in a simple, dedicated header
 * file, these can be replaced.
 */

/* MWPSMOD_MAX_KEY: maximum key length. */
#define MWPSMOD_MAX_KEY 64

/* MWPSMOD_PIN_LEN: Length of the wps pin */
#define MWPSMOD_PIN_LEN 8

/* enum mwpsmod_auth: authentication types used for credentials
 */
enum mwpsmod_auth {
    MWPSMOD_AUTH_OPEN = 0x0001,
    MWPSMOD_AUTH_WPA2ENT = 0x0010,
    MWPSMOD_AUTH_WPA2PSK = 0x0020,
};

/* enum mwpsmod_encrypt: encryption types used for credentials
 */
enum mwpsmod_encrypt {
    MWPSMOD_ENCRYPT_NONE = 0x0000,
    MWPSMOD_ENCRYPT_TKIP = 0x0004,
    MWPSMOD_ENCRYPT_AES = 0x0008,
};

/* mwpsmod_credential: structure representing network credentials
 *
 * ssid: SSID of the network for which this credential is valid
 *
 * auth: Authentication scheme(s) used by the network
 *
 * encrypt: Encryption scheme(s) used by the network
 *
 * key: The network key.  If the strlen of the key is 64, it is a
 * null-terminated 32-byte PSK repreasented as 64 hex chars.  If strlen is less
 * than 64, key is a null-terminated ascii passphrase.  If strlen is 0, key is
 * ignored and the network is open.
 */
struct mwpsmod_credential {
    char ssid[MAX_SSID_LEN + 1];
    unsigned short auth;
    unsigned short encrypt;
    char key[MWPSMOD_MAX_KEY + 1];
};

/* mwpsmod_device: structure representing an enrollee or registrar device
 *
 * mac: the mac address of the device.
 *
 * device_name: the null-terminated name of the device.
 *
 * model_name: the null-terminated model name of the device.
 *
 * model_number: the null-terminated model number of the device.
 *
 * methods: supported configuration methods.  This is the bit-wise OR of any
 * number of enum module_config_method
 */
struct mwpsmod_device {
    unsigned char mac[ETH_ALEN];
    char device_name[MAX_DEVICE_NAME_LEN + 1];
    char model_name[MAX_DEVICE_NAME_LEN + 1];
    char model_number[MAX_DEVICE_NAME_LEN + 1];
    unsigned short methods;
};

/* mwpsmod_registrar_configuration:
 *
 * dev: device info for the registrar
 *
 * cred: credential info being served up by this registrar
 */
struct mwpsmod_registrar_config {
    struct mwpsmod_device dev;
    struct mwpsmod_credential cred;
};

/* mwpsmod_registrar_info: runtime stats and parameters for the registrar
 *
 */
struct mwpsmod_registrar_info {

};

/* mwpsmod_enrollee_config:
 *
 * dev: device info for the enrollee
 */
struct mwpsmod_enrollee_config {
    struct mwpsmod_device dev;
};

/* mwpsmod_enrollee_info: start-time info for enrollee
 *
 * registrar_mac: mac address of the registrar with whom to register
 *
 * pin: the 8-digit null-terminated ascii pin to be used for wps.
 */
struct mwpsmod_enrollee_info {
    unsigned char registrar_mac[ETH_ALEN];
    char pin[MWPSMOD_PIN_LEN + 1];
};

/* enum mwpsmod_event_type
 *
 * These are event types that are emitted from the mwpsmod module.
 *
 * MWPSMOD_EVENT_ENROLLEE_DONE: The caller can expect this event after a
 * successful call to mwpsmod_enrollee_start().  After this event,
 * mwpsmod_enrollee_start() can be called again to restart wps with the same
 * registrar or a new registrar.  The following are the meanings of the status
 * codes and val member.
 *
 *     MWPSMOD_ERR_SUCCESS: enrolling with the registrar succeeded.  In this
 *     case, the val member of the event will be a struct mwpsmod_credential
 *     containing the credentials for the network.
 *
 *     MWPSMOD_ERR_NOTREADY: the registrar is not ready to enroll us because it
 *     does not know the PIN for the device.  The user should be instructed to
 *     enter the pin into the registrar or to push the registrar's button.  In
 *     this case, val is a struct mwpsmod_device describing the registrar.
 *
 *     MWPSMOD_ERR_NAK: We received a NAK from the registrar.  Perhaps it was
 *     busy, or perhaps the pins did not match.  val should not be
 *     dereferenced.
 *
 *     MWPSMOD_ERR_COM: A low-level driver issue occured.  val should not be
 *     dereferenced.
 *
 *     MWPSMOD_ERR_NOENT: Registrar with the mac address specified to
 *     mwpsmod_enrollee_start() could not be found.  val should not be
 *     dereferenced.
 *
 *     MWPSMOD_ERR_TIMEOUT: Timed out waiting for registration to complete.
 *
 * MWPSMOD_EVENT_REGISTRAR_DONE: wps with an enrollee has completed.  The
 * caller can expect this after a successful call to
 * mwpsmod_registrar_set_pin().  After this event, mwpsmod_registrar_set_pin()
 * can be called again with the pin for another enrollee.  The following are
 * the meanings the status codes and val members:
 *
 *     MWPSMOD_ERR_SUCCESS: enrollee successfully enrolled and has acqiured the
 *     credential specified when mwpsmod_registrar_start() was called.  The
 *     registrar will continue to answer the requests of other enrollees until
 *     mwpsmod_registrar_stop() or mwpsmod_registrar_deinit() is called.  val
 *     is a struct mwpsmod_device describing the enrollee.
 *
 *     MWPSMOD_ERR_NOTREADY: An enrollee attempted to enroll, but
 *     mwpsmod_registrar_set_pin() has not been called.  In this case, val is a
 *     struct mwpsmod_device describing the enrollee.  The registrar may (or
 *     may not) wish to present some user interface to allow the enrollee user
 *     to enter a pin or push a button.
 *
 *     MWPSMOD_ERR_NAK: We received a NAK from the enrollee.  Perhaps it was
 *     busy, or perhaps the pins did not match.
 *
 *     MWPSMOD_ERR_COM: A low-level driver issue occured.
 *
 *     MWPSMOD_ERR_TIMEOUT: mwpsmod_registrar_set_pin() was called, but no
 *     enrollee attempted to register during the 120-second "walk time".
 *
 */
enum mwpsmod_event_type {
    MWPSMOD_EVENT_ENROLLEE_DONE,
    MWPSMOD_EVENT_REGISTRAR_DONE,
};

/* mwpsmod_launch: launch the wps module
 *
 * This function must be called at boot time to start the wps module.
 * After this call, the init functions can be called.
 */
enum mwpsmod_error mwpsmod_launch(void);

/* mwpsmod_halt: halt the wps module
 *
 * Any wps communication underway will be terminated.  This should be called at
 * system shutdown time, presumably by the same entity that called
 * mwpsmod_launch.
 */
void mwpsmod_halt(void);

/* mwpsmod_enrollee_init: initialize as an enrollee
 *
 * mod: A non-NULL module descriptor.  The interface must be set to the valid
 * system interface string for the interface on which the module should
 * operate.  If the callback is NULL, no events will be emitted.
 *
 * cfg: configuration information for the enrollee describing the various names
 * and supported configuration methods to be advertised.  If cfg is NULL, the
 * default configuration will be used.
 *
 * returns:
 *
 * MWPSMOD_ERR_SUCCESS: The operation succeeded.  mwpsmod_enrollee_start() may be
 * called to start wps.
 *
 * MWPSMOD_ERR_COM: An internal/driver error has occurred, and wps cannot be
 * initialized.
 *
 * MWPSMOD_ERR_NOMEM: Memory allocation failed.
 *
 * MWPSMOD_ERR_INVAL: Some config information was not valid.
 *
 * NOTE: The default configuration can be retrieved with a call to
 * mwpsmod_enrollee_get_info() after invoking mwpsmod_enrollee_init() with a
 * NULL cfg.
 */
enum mwpsmod_error mwpsmod_enrollee_init(struct module *mod,
                                         struct mwpsmod_enrollee_config *cfg);

/* mwpsmod_enrollee_deinit: de-initialize the enrollee
 *
 * mod: The non-NULL module descriptor that has been initialized by a
 * successful call to mwpsmod_enrollee_init().
 *
 * After calling this function, either the enrollee or the registrar can be
 * initialized again.  If any wps is underway when this function is called, it
 * will be canceled.
 */
void mwpsmod_enrollee_deinit(struct module *mod);

/* mwpsmod_enrollee_start: start the enrollee
 *
 * mod: The non-NULL module descriptor that has been initialized by a
 * successful call to mwpsmod_enrollee_init().
 *
 * enrollee_info: parameters for enrollee to use to register (e.g., registrar
 * mac and pin).
 *
 * returns:
 *
 * MWPSMOD_ERR_SUCCESS: The operation succeeded and the user can expect a
 * MWPSMOD_EVENT_ENROLLEE_DONE.
 *
 * MWPSMOD_ERR_BUSY: mwpsmod is busy.  Perhaps start was already called.
 *
 * MWPSMOD_ERR_COM: A low-level driver or communication issue has occurred and
 * the enrollee could not be started.
 *
 * MWPSMOD_ERR_INVAL: An input was invalid.
 *
 * MWPSMOD_ERR_NOTREADY: mwpsmod_enrollee_init() was not called or did not
 * succeed.
 */
enum mwpsmod_error mwpsmod_enrollee_start(struct module *mod,
                                  struct mwpsmod_enrollee_info *enrollee_info);

/* mwpsmod_enrollee_stop: stop the enrollee
 *
 * mod: The non-NULL module descriptor that has been initialized by a
 * successful call to mwpsmod_enrollee_init().
 */
void mwpsmod_enrollee_stop(struct module *mod);

/* mwpsmod_enrollee_get_info: Get current stats and settings for enrollee
 *
 * mod: The non-NULL module descriptor that has been initialized by a
 * successful call to mwpsmod_enrollee_init().
 *
 * cfg: non-NULL structure that will be populated with the current
 * configuration of the enrollee.
 *
 * enrollee_info: non-NULL structure that will be populated with the current
 * runtime stats and parameters for this enrollee.
 *
 * returns:
 *
 * MWPSMOD_ERR_SUCCESS: The command succeeded and the argument structures have
 * been populated.
 *
 * MWPSMOD_ERR_COM: A low-level/driver issue occured.  Data in argument structs
 * is not valid.
 *
 * MWPSMOD_ERR_INVAL: An input parameter was invalid (i.e., NULL).
 *
 * NOTE: If mwpsmod_enrollee_start() has been called, the enrollee_info struct
 * will contain the same data passed to that function.  If
 * mwpsmod_enrolle_stop() has been called, or if MWPSMOD_EVENT_ENROLLEE_DONE
 * has been emitted, or if mwpsmod_enrollee_start() has never been called, or
 * if mwpsmod_enrollee_init() was called with a NULL cfg, the struct will be
 * set with default configuration information.
 */
enum mwpsmod_error mwpsmod_enrollee_get_info(struct module *mod,
                                  struct mwpsmod_enrollee_config *cfg,
                                  struct mwpsmod_enrollee_info *enrollee_info);

/* mwpsmod_registrar_init: initialize as a registrar
 *
 * mod: A non-NULL module descriptor.  The interface must be set to the valid
 * system interface string for the interface on which the module should
 * operate.  If the callback is NULL, no events will be emitted.
 *
 * cfg: configuration information describing the various names, supported
 * configuration methods, and credential info to be used by the registrar.
 * Pass NULL if you wish to use the default configuration.
 *
 * returns:
 *
 * MWPSMOD_ERR_SUCCESS: The operation succeeded.  mwpsmod_registrar_start() may
 * be called to start the registrar.
 *
 * MWPSMOD_ERR_BUSY: mwpsmod is busy (e.g., already initialized).  The
 * appropriate deinit function must be called before calling this function.
 *
 * MWPSMOD_ERR_COM: An internal/driver error has occurred, and mwpsmod cannot
 * be initialized.
 *
 * MWPSMOD_ERR_INVAL: An input was invalid.
 */
enum mwpsmod_error mwpsmod_registrar_init(struct module *mod,
                                      struct mwpsmod_registrar_config *cfg);

/* mwpsmod_registrar_deinit: de-initialize the registrar
 *
 * mod: The non-NULL module descriptor that has been initialized by a
 * successful call to mwpsmod_registrar_init().
 *
 * After calling this function, either the enrollee or the registrar can be
 * initialized again.  If any wps is underway when this function is called, it
 * will be canceled.
 */
void mwpsmod_registrar_deinit(struct module *mod);

/* mwpsmod_registrar_start: start the registrar
 *
 * mod: The non-NULL module descriptor that has been initialized by a
 * successful call to mwpsmod_registrar_init().
 *
 * returns:
 *
 * MWPSMOD_ERR_SUCCESS: The operation succeeded and the user can expect
 * MWPSMOD_EVENT_REGISTRAR_DONE events as enrollees attempt to register.
 *
 * MWPSMOD_ERR_BUSY: mwpsmod is busy.  Perhaps start was already called, or
 * mwpsmod has been configured as an enrollee.
 *
 * MWPSMOD_ERR_COM: A low-level driver or communication issue has occurred and
 * the registrar could not be started.
 *
 * MWPSMOD_ERR_NOTREADY: mwpsmod_registrar_init() was not called or did not
 * succeed.
 */
enum mwpsmod_error mwpsmod_registrar_start(struct module *mod);

/* mwpsmod_registrar_stop: stop the registrar
 *
 * mod: The non-NULL module descriptor that has been initialized by a
 * successful call to mwpsmod_registrar_init().
 */
void mwpsmod_registrar_stop(struct module *mod);

/* mwpsmod_registrar_get_info: Get current stats and settings for registrar
 *
 * mod: The non-NULL module descriptor that has been initialized by a
 * successful call to mwpsmod_registrar_init().
 *
 * cfg: non-NULL structure that will be populated with the current
 * configuration of the registrar.
 *
 * registrar_info: non-NULL structure that will be populated with the current
 * runtime stats and parameters for this registrar.
 *
 * returns:
 *
 * MWPSMOD_ERR_SUCCESS: The command succeeded and dev and registrar_info have
 * been populated with the current stats and settings.
 *
 * MWPSMOD_ERR_COM: A low-level/driver issue occured.  Data in dev and
 * registrar_info is not valid.
 *
 * MWPSMOD_ERR_INVAL: An input parameter was invalid (i.e., NULL).
 *
 * NOTE: The cfg struct will contain the same configuration info passed to
 * mwpsmod_registrar_init().  If NULL was passed, cfg will be populated with
 * the default configuration.
 *
 * NOTE: If mwpsmod_registrar_set_info() has never been called, the parameters
 * in registrar_info will be populated with their default values.
 */
enum mwpsmod_error mwpsmod_registrar_get_info(struct module *mod,
                              struct mwpsmod_registrar_config *cfg,
                              struct mwpsmod_registrar_info *registrar_info);

/* mwpsmod_registrar_set_info: Set stats and runtime parameters for registrar
 *
 * mod: The non-NULL module descriptor that has been initialized by a
 * successful call to mwpsmod_registrar_init().
 *
 * registrar_info: non-NULL settings and stat info to apply to the registrar
 *
 * returns:
 *
 * MWPSMOD_ERR_SUCCESS: The command succeeded.  The data in registrar_info has been
 * applied.
 *
 * MWPSMOD_ERR_COM: A low-level/driver issue occured.
 *
 * MWPSMOD_ERR_BUSY: The module is currently busy and the data in
 * registrar_info could not be applied.
 *
 * MWPSMOD_ERR_INVAL: An input parameter in registrar_info was invalid.
 */
enum mwpsmod_error mwpamod_registrar_set_info(struct module *mod,
                              struct mwpsmod_registrar_info *registrar_info);

/* mwpsmod_registrar_set_pin: set the pin to be used for wps
 *
 * mod: The non-NULL module descriptor that has been initialized by a
 * successful call to mwpsmod_registrar_init().
 *
 * pin: pointer the pin, a null-terminated 8-digit string of ascii characters
 * 0-9.
 *
 * returns:
 *
 * MWPSMOD_ERR_SUCCESS: The operation succeeded.  Forthcoming wps requests will
 * use the specified pin.  Expect a MWPSMOD_EVENT_REGISTRAR_DONE when
 * registration either completes or times out.
 *
 * MWPSMOD_ERR_INVAL: The pin is not a valid WPS pin.
 *
 * MWPSMOD_ERR_BUSY: mwpsmod_registrar_set_pin() was called and
 * MWPSMOD_EVENT_REGISTRAR_DONE has not yet been emitted.
 *
 * NOTE: for PBC mode, the pin must be null
 *
 */
enum mwpsmod_error mwpsmod_registrar_set_pin(struct module *mod, char *pin);

/* mwpsmod_random_pin: get a random pin for use in wps
 *
 * pin: pointer to memory where the pin will be saved.  The pin will be a
 * null-terminated 8-digit string of ascii characters 0-9.
 */
void mwpsmod_random_pin(char *pin);

#endif
